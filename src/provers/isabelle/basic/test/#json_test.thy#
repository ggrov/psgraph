theory json_test                                           
imports        
  "../build/BIsaP"    
begin
ML{*-
  val path = "/u1/staff/gg112/";
*}
ML{*
  val path = "/Users/yuhuilin/Desktop/" ;
*}
ML{*
  val path = "/home/pierre/Documents/HW/Job2014/" ;
*}


(* test psgraph level *)

ML{*
(* setting up a psgraph for testing *)
  fun at_impI_tac _ i _ = rtac @{thm impI} i;
  fun at_conjI_tac _ i _ = rtac @{thm conjI} i;
  fun at_atac _ i _ = atac i;
  fun at_all_tac  _ _ _ = all_tac

  val asm =  Data.T_Atomic {name = "atac", args = [[]]}; 
  val allT =  Data.T_Atomic {name = "all_tac", args = [[]]}; 
  val impI =  Data.T_Atomic {name = "impI", args = [[]]}; 
  val conjI =  Data.T_Atomic {name = "conjI", args = [[]]}; 

  fun load_atom ps =  PSGraph.load_atomics 
    [("all_tac", at_all_tac), ("atac", at_atac), ("impI", at_impI_tac), ("conjI", at_conjI_tac)] 
    ps;

  val gt = Data.GT SimpleGoalTyp.default;
  val gt_imp =  Data.GT "top_symbol(HOL.implies)";
  val gt_conj = Data.GT "top_symbol(HOL.conj)";
  
  infixr 6 THENG; 
  val op THEN = PSComb.THEN;

  
  val psasm =  PSComb.LIFT ([gt],[gt]) (asm);
  val psall =  PSComb.LIFT ([gt],[gt]) (allT);
  val psimpI = PSComb.LIFT ([gt_imp, gt_imp],[gt_imp, gt]) (impI);
  val psconjI =  PSComb.LIFT ([gt_conj],[gt_imp]) (conjI);

  val ps = psconjI THEN ((PSComb.LOOP_WITH gt_imp psimpI) THEN psasm)
    |> load_atom;
*}

ML{*

val g = PSGraph.get_graph ps;
Theory_IO.write_json_file (path^"test.psgraph") g;
*}

ML{*
(* the file should be identical with the one above *)
val out_test = Theory_IO.out_json g;
val in_test = Theory_IO.in_json out_test;
Theory_IO.write_json_file (path^"in_test.psgraph") in_test;
*}

 
ML{*
 PSGraph.write_json_file (path^"test0.psgraph") ps;
*}  
ML{* 
  val edata0 = EVal.init ps @{context} @{prop "(B \<longrightarrow> B)  \<and> (B\<longrightarrow> A \<longrightarrow> A)"} |> hd; 
*} 
(* socket testing *)  
         
ML{* val s = TextSocket.local_client 1790; *}
ML{*  
val msg = IEVal.output_string "CMD_INIT_PSGRAPH" (SOME edata0);
File_Io.write_string (path^"/msg.json") msg;
*}  
ML{* -
TextSocket.write s msg; 
TextSocket.flushOut s;
TextSocket.read s; (* expect to be "can you hear me" *) 
*}

ML{*-
TextSocket.read s; (* expect to be "can you hear me" *) 
*}

ML{*  
TextSocket.write s msg; 
TextSocket.flushOut s;
*}

ML{*-
val s = TextSocket.safe_local_client 1790; 
TextSocket.write s "hello 2 from client \n"; 
TextSocket.flushOut s;
TextSocket.read s; (* expect to be "can you hear me" *)

TextSocket.write s "say hello 2  from the client\n"; 
TextSocket.flushOut s;
*}
 
ML{*-
TextSocket.write s "CMD_CLOSE\n";
TextSocket.flushOut s;
*}
