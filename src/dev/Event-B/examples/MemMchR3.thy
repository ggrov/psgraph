(* File containing proof obligations. Do not edit this file. *)
theory "MemMchR3" imports "~~/contrib/HOL-EventB/EventB" begin

typedecl "Inst"
typedecl "Data"
typedecl "Status"

locale "DualOpOk_grd9_GRD_decls" =
fixes "Int2Data" :: "(Int.int \<times> Data) Set.set"
fixes "instArray" :: "(Int.int \<times> Inst) Set.set"
fixes "Inst2ImmDataLong" :: "(Inst \<times> Data) Set.set"
fixes "Inst2DstIndex" :: "(Inst \<times> Int.int) Set.set"
fixes "DataByte" :: "Data Set.set"
fixes "FetchImmInst" :: "Inst Set.set"
fixes "IncrInst" :: "Inst Set.set"
fixes "FetchMemInstSize" :: "Int.int"
fixes "MoveInst" :: "Inst Set.set"
fixes "Inst2Src2Index" :: "(Inst \<times> Int.int) Set.set"
fixes "FlowInst" :: "Inst Set.set"
fixes "ValidInst" :: "Inst Set.set"
fixes "DataLongSize" :: "Int.int"
fixes "MemWriteInstSize" :: "Int.int"
fixes "FetchMemInst" :: "Inst Set.set"
fixes "funcOk" :: "HOL.bool"
fixes "Int2DataLong" :: "(Int.int \<times> Data) Set.set"
fixes "op2Data" :: "Data"
fixes "DataShortSize" :: "Int.int"
fixes "JumpInst" :: "Inst Set.set"
fixes "FetchImmShortInst" :: "Inst Set.set"
fixes "NullInstSize" :: "Int.int"
fixes "Null2Inst" :: "Inst Set.set"
fixes "FetchImmByteInst" :: "Inst Set.set"
fixes "Inst2ImmData" :: "(Inst \<times> Data) Set.set"
fixes "RegWriteInst" :: "Inst Set.set"
fixes "FetchInst" :: "Inst Set.set"
fixes "DataShort" :: "Data Set.set"
fixes "op2Index" :: "Int.int"
fixes "inst" :: "Inst"
fixes "MaxVector" :: "Int.int"
fixes "MoveInstSize" :: "Int.int"
fixes "MaxRegIndex" :: "Int.int"
fixes "MaxMemPointer" :: "Int.int"
fixes "SingleOpFuncDataLong" :: "(Data \<times> (Data \<times> HOL.bool)) Set.set"
fixes "status" :: "Status"
fixes "NullInst" :: "Inst Set.set"
fixes "Int2DataByte" :: "(Int.int \<times> Data) Set.set"
fixes "dstIndex" :: "Int.int"
fixes "SingleOpInstSize" :: "Int.int"
fixes "FetchInstPtrInstSize" :: "Int.int"
fixes "FetchImmInstSize" :: "Int.int"
fixes "regArray" :: "(Int.int \<times> Data) Set.set"
fixes "instPtr" :: "Int.int"
fixes "DataByteInt" :: "Int.int Set.set"
fixes "Inst2SrcIndex" :: "(Inst \<times> Int.int) Set.set"
fixes "MemArrayDom" :: "Int.int Set.set"
fixes "FetchInstPtrInst" :: "Inst Set.set"
fixes "BranchInst" :: "Inst Set.set"
fixes "instr" :: "Inst"
fixes "InstArrayDom" :: "Int.int Set.set"
fixes "LOADING" :: "Status"
fixes "DualOpFunc" :: "((Data \<times> Data) \<times> (Data \<times> HOL.bool)) Set.set"
fixes "memArrayDataLong" :: "(Int.int \<times> Data) Set.set"
fixes "DataLongInt" :: "Int.int Set.set"
fixes "DataByte2Int" :: "(Data \<times> Int.int) Set.set"
fixes "DataLong" :: "Data Set.set"
fixes "FetchImmLongInst" :: "Inst Set.set"
fixes "regArrayDataLong" :: "(Int.int \<times> Data) Set.set"
fixes "MinMemPointer" :: "Int.int"
fixes "memArray" :: "(Int.int \<times> Data) Set.set"
fixes "InvalidInst" :: "Inst Set.set"
fixes "RegArrayDom" :: "Int.int Set.set"
fixes "srcData" :: "Data"
fixes "Inst2ImmDataByte" :: "(Inst \<times> Data) Set.set"
fixes "SingleOpFunc" :: "(Data \<times> (Data \<times> HOL.bool)) Set.set"
fixes "MinRegIndex" :: "Int.int"
fixes "op1Index" :: "Int.int"
fixes "DualOpInstSize" :: "Int.int"
fixes "RUNNING" :: "Status"
fixes "SingleOpInst" :: "Inst Set.set"
fixes "ExecInst" :: "Inst Set.set"
fixes "Inst2ImmDataShort" :: "(Inst \<times> Data) Set.set"
fixes "FAILED" :: "Status"
fixes "DataLong2Int" :: "(Data \<times> Int.int) Set.set"
fixes "DualOpFuncDataLong" :: "((Data \<times> Data) \<times> (Data \<times> HOL.bool)) Set.set"
fixes "DualOpInst" :: "Inst Set.set"
fixes "MemWriteInst" :: "Inst Set.set"
fixes "DataByteSize" :: "Int.int"
fixes "StopInst" :: "Inst Set.set"
fixes "HALTED" :: "Status"
fixes "op1Data" :: "Data"
fixes "DataInt" :: "Int.int Set.set"
fixes "Data2Int" :: "(Data \<times> Int.int) Set.set"

locale "DualOpOk_grd9_GRD_hyps" = "DualOpOk_grd9_GRD_decls" +
assumes "hyp_0": "T (EB_Log.bnoteq (UNIV::Inst Set.set)\<up> (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_1": "T (EB_Set.bsubseteq ValidInst\<up> (UNIV::Inst Set.set)\<up>)"
assumes "hyp_2": "T (EB_Log.bnoteq ValidInst\<up> (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_3": "T (EB_Set.bsubseteq InvalidInst\<up> (UNIV::Inst Set.set)\<up>)"
assumes "hyp_4": "T (EB_Log.bnoteq InvalidInst\<up> (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_5": "T (EB_Log0.beq (UNIV::Inst Set.set)\<up> (ValidInst\<up> .\<union>. InvalidInst\<up>))"
assumes "hyp_6": "T (EB_Log0.beq (ValidInst\<up> .\<inter>. InvalidInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_7": "T (EB_Set.bnsubseteq InvalidInst\<up> ValidInst\<up>)"
assumes "hyp_8": "T (EB_Set.bsubseteq ExecInst\<up> ValidInst\<up>)"
assumes "hyp_9": "T (EB_Log.bnoteq ExecInst\<up> (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_10": "T (EB_Set.bsubseteq StopInst\<up> ValidInst\<up>)"
assumes "hyp_11": "T (EB_Log.bnoteq StopInst\<up> (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_12": "T (EB_Log0.beq ValidInst\<up> (ExecInst\<up> .\<union>. StopInst\<up>))"
assumes "hyp_13": "T (EB_Log0.beq (ExecInst\<up> .\<inter>. StopInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_14": "T (EB_Set.bsubseteq IncrInst\<up> ExecInst\<up>)"
assumes "hyp_15": "T (EB_Log.bnoteq IncrInst\<up> (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_16": "T (EB_Set.bsubseteq FlowInst\<up> ExecInst\<up>)"
assumes "hyp_17": "T (EB_Log.bnoteq FlowInst\<up> (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_18": "T (EB_Log0.beq ExecInst\<up> (IncrInst\<up> .\<union>. FlowInst\<up>))"
assumes "hyp_19": "T (EB_Log0.beq (IncrInst\<up> .\<inter>. FlowInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_20": "T (EB_Log0.beq (IncrInst\<up> .\<inter>. StopInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_21": "T (EB_Log0.beq (FlowInst\<up> .\<inter>. StopInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_22": "T (EB_Set.bsubseteq BranchInst\<up> FlowInst\<up>)"
assumes "hyp_23": "T (EB_Set.bsubseteq JumpInst\<up> FlowInst\<up>)"
assumes "hyp_24": "T (EB_Log0.beq (BranchInst\<up> .\<inter>. JumpInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_25": "T (EB_Log0.beq FlowInst\<up> (BranchInst\<up> .\<union>. JumpInst\<up>))"
assumes "hyp_26": "T (EB_Set.bsubseteq NullInst\<up> IncrInst\<up>)"
assumes "hyp_27": "T (EB_Set0.bin NullInstSize\<up> (EB_Int.bnatn))"
assumes "hyp_28": "T (EB_Set.bsubseteq RegWriteInst\<up> IncrInst\<up>)"
assumes "hyp_29": "T (EB_Log0.beq (NullInst\<up> .\<inter>. RegWriteInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_30": "T (EB_Log0.beq IncrInst\<up> (NullInst\<up> .\<union>. RegWriteInst\<up>))"
assumes "hyp_31": "T (EB_Set.bsubseteq FetchInst\<up> RegWriteInst\<up>)"
assumes "hyp_32": "T (EB_Set.bsubseteq MoveInst\<up> RegWriteInst\<up>)"
assumes "hyp_33": "T (EB_Set.bsubseteq SingleOpInst\<up> RegWriteInst\<up>)"
assumes "hyp_34": "T (EB_Set.bsubseteq DualOpInst\<up> RegWriteInst\<up>)"
assumes "hyp_35": "T (EB_Log0.beq (FetchInst\<up> .\<inter>. MoveInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_36": "T (EB_Log0.beq (FetchInst\<up> .\<inter>. SingleOpInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_37": "T (EB_Log0.beq (FetchInst\<up> .\<inter>. DualOpInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_38": "T (EB_Log0.beq (MoveInst\<up> .\<inter>. SingleOpInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_39": "T (EB_Log0.beq (MoveInst\<up> .\<inter>. DualOpInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_40": "T (EB_Log0.beq (SingleOpInst\<up> .\<inter>. DualOpInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_41": "T (EB_Log0.beq RegWriteInst\<up> (FetchInst\<up> .\<union>. MoveInst\<up> .\<union>. SingleOpInst\<up> .\<union>. DualOpInst\<up>))"
assumes "hyp_42": "T (EB_Log.btrue)"
assumes "hyp_43": "T (EB_Set0.bin MoveInstSize\<up> (EB_Int.bnatn))"
assumes "hyp_44": "T (EB_Set0.bin SingleOpInstSize\<up> (EB_Int.bnatn))"
assumes "hyp_45": "T (EB_Set0.bin DualOpInstSize\<up> (EB_Int.bnatn))"
assumes "hyp_46": "T (EB_Set.bsubseteq FetchInstPtrInst\<up> FetchInst\<up>)"
assumes "hyp_47": "T (EB_Set.bsubseteq FetchImmInst\<up> FetchInst\<up>)"
assumes "hyp_48": "T (EB_Set.bsubseteq FetchMemInst\<up> FetchInst\<up>)"
assumes "hyp_49": "T (EB_Log0.beq (FetchInstPtrInst\<up> .\<inter>. FetchImmInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_50": "T (EB_Log0.beq (FetchInstPtrInst\<up> .\<inter>. FetchMemInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_51": "T (EB_Log0.beq (FetchImmInst\<up> .\<inter>. FetchMemInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_52": "T (EB_Log0.beq FetchInst\<up> (FetchInstPtrInst\<up> .\<union>. FetchImmInst\<up> .\<union>. FetchMemInst\<up>))"
assumes "hyp_53": "T (EB_Set0.bin FetchInstPtrInstSize\<up> (EB_Int.bnatn))"
assumes "hyp_54": "T (EB_Set0.bin FetchImmInstSize\<up> (EB_Int.bnatn))"
assumes "hyp_55": "T (EB_Set0.bin FetchMemInstSize\<up> (EB_Int.bnatn))"
assumes "hyp_56": "T (EB_Set.bsubseteq Null2Inst\<up> NullInst\<up>)"
assumes "hyp_57": "T (EB_Set.bsubseteq MemWriteInst\<up> NullInst\<up>)"
assumes "hyp_58": "T (EB_Log0.beq (Null2Inst\<up> .\<inter>. MemWriteInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_59": "T (EB_Log0.beq (Null2Inst\<up> .\<union>. MemWriteInst\<up>) NullInst\<up>)"
assumes "hyp_60": "T (EB_Set0.bin MemWriteInstSize\<up> (EB_Int.bnatn))"
assumes "hyp_61": "T (EB_Set.bsubseteq FetchImmByteInst\<up> FetchImmInst\<up>)"
assumes "hyp_62": "T (EB_Set.bsubseteq FetchImmShortInst\<up> FetchImmInst\<up>)"
assumes "hyp_63": "T (EB_Set.bsubseteq FetchImmLongInst\<up> FetchImmInst\<up>)"
assumes "hyp_64": "T (EB_Log0.beq FetchImmInst\<up> (FetchImmByteInst\<up> .\<union>. FetchImmShortInst\<up> .\<union>. FetchImmLongInst\<up>))"
assumes "hyp_65": "T (EB_Log0.beq (FetchImmByteInst\<up> .\<inter>. FetchImmShortInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_66": "T (EB_Log0.beq (FetchImmShortInst\<up> .\<inter>. FetchImmLongInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_67": "T (EB_Log0.beq (FetchImmLongInst\<up> .\<inter>. FetchImmByteInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
assumes "hyp_68": "T (EB_Log0.beq (UNIV::Status Set.set)\<up> {.LOADING\<up>, RUNNING\<up>, FAILED\<up>, HALTED\<up>.})"
assumes "hyp_69": "T (EB_Log.bnoteq LOADING\<up> RUNNING\<up>)"
assumes "hyp_70": "T (EB_Log.bnoteq LOADING\<up> FAILED\<up>)"
assumes "hyp_71": "T (EB_Log.bnoteq LOADING\<up> HALTED\<up>)"
assumes "hyp_72": "T (EB_Log.bnoteq RUNNING\<up> FAILED\<up>)"
assumes "hyp_73": "T (EB_Log.bnoteq RUNNING\<up> HALTED\<up>)"
assumes "hyp_74": "T (EB_Log.bnoteq FAILED\<up> HALTED\<up>)"
assumes "hyp_75": "T (EB_Log.bnoteq (UNIV::Data Set.set)\<up> (EB_Set.bemptyset :: Data Set.set\<up>))"
assumes "hyp_76": "T (EB_Set0.bin SingleOpFunc\<up> (EB_Rel.btfun (UNIV::Data Set.set)\<up> (EB_Rel.bcprod (UNIV::Data Set.set)\<up> (EB_Bool.bbool))))"
assumes "hyp_77": "T (EB_Set0.bin DualOpFunc\<up> (EB_Rel.btfun (EB_Rel.bcprod (UNIV::Data Set.set)\<up> (UNIV::Data Set.set)\<up>) (EB_Rel.bcprod (UNIV::Data Set.set)\<up> (EB_Bool.bbool))))"
assumes "hyp_78": "T (EB_Set.bsubseteq DataLong\<up> (UNIV::Data Set.set)\<up>)"
assumes "hyp_79": "T (EB_Log.bnoteq DataLong\<up> (EB_Set.bemptyset :: Data Set.set\<up>))"
assumes "hyp_80": "T (EB_Set.bsubseteq DataShort\<up> DataLong\<up>)"
assumes "hyp_81": "T (EB_Log.bnoteq DataShort\<up> (EB_Set.bemptyset :: Data Set.set\<up>))"
assumes "hyp_82": "T (EB_Set.bsubseteq DataByte\<up> DataShort\<up>)"
assumes "hyp_83": "T (EB_Log.bnoteq DataByte\<up> (EB_Set.bemptyset :: Data Set.set\<up>))"
assumes "hyp_84": "T (EB_Set0.bin DataLongSize\<up> (EB_Int.bnatn))"
assumes "hyp_85": "T (EB_Set0.bin DataShortSize\<up> (EB_Int.bnatn))"
assumes "hyp_86": "T (EB_Int.ble DataShortSize\<up> DataLongSize\<up>)"
assumes "hyp_87": "T (EB_Set0.bin DataByteSize\<up> (EB_Int.bnatn))"
assumes "hyp_88": "T (EB_Int.ble DataByteSize\<up> DataShortSize\<up>)"
assumes "hyp_89": "T (\<forall>^ (x::Data). (EB_Log.bimp (EB_Set0.bin x\<up> DataShort\<up>) (EB_Set0.bin x\<up> DataLong\<up>)))"
assumes "hyp_90": "T (\<forall>^ (x::Data). (EB_Log.bimp (EB_Set0.bin x\<up> DataByte\<up>) (EB_Set0.bin x\<up> DataShort\<up>)))"
assumes "hyp_91": "T (EB_Set.bsubseteq DataByte\<up> DataLong\<up>)"
assumes "hyp_92": "T (\<forall>^ (x::Data). (EB_Log.bimp (EB_Set0.bin x\<up> DataByte\<up>) (EB_Set0.bin x\<up> DataLong\<up>)))"
assumes "hyp_93": "T (EB_Set0.bin SingleOpFuncDataLong\<up> (EB_Rel.btfun DataLong\<up> (EB_Rel.bcprod DataLong\<up> (EB_Bool.bbool))))"
assumes "hyp_94": "T (\<forall>^ (a::Data). (EB_Log.bimp (EB_Set0.bin a\<up> DataLong\<up>) (EB_Log0.beq (EB_Rel.bfunimg SingleOpFuncDataLong\<up> a\<up>) (EB_Rel.bfunimg SingleOpFunc\<up> a\<up>))))"
assumes "hyp_95": "T (EB_Set0.bin DualOpFuncDataLong\<up> (EB_Rel.btfun (EB_Rel.bcprod DataLong\<up> DataLong\<up>) (EB_Rel.bcprod DataLong\<up> (EB_Bool.bbool))))"
assumes "hyp_96": "T (\<forall>^ (a::Data) (b::Data). (EB_Log.bimp ((EB_Set0.bin a\<up> DataLong\<up>) ^\<and>^ (EB_Set0.bin b\<up> DataLong\<up>)) (EB_Log0.beq (EB_Rel.bfunimg DualOpFuncDataLong\<up> (EB_Prod.bmapsto a\<up> b\<up>)) (EB_Rel.bfunimg DualOpFunc\<up> (EB_Prod.bmapsto a\<up> b\<up>)))))"
assumes "hyp_97": "T (EB_Set0.bin Inst2ImmData\<up> (EB_Rel.btfun (UNIV::Inst Set.set)\<up> (UNIV::Data Set.set)\<up>))"
assumes "hyp_98": "T (EB_Set0.bin Inst2ImmDataByte\<up> (EB_Rel.btfun (UNIV::Inst Set.set)\<up> DataByte\<up>))"
assumes "hyp_99": "T (\<forall>^ (i::Inst). (EB_Log.bimp (EB_Set0.bin i\<up> (UNIV::Inst Set.set)\<up>) (EB_Log0.beq (EB_Rel.bfunimg Inst2ImmDataByte\<up> i\<up>) (EB_Rel.bfunimg Inst2ImmData\<up> i\<up>))))"
assumes "hyp_100": "T (EB_Set0.bin Inst2ImmDataShort\<up> (EB_Rel.btfun (UNIV::Inst Set.set)\<up> DataShort\<up>))"
assumes "hyp_101": "T (\<forall>^ (i::Inst). (EB_Log.bimp (EB_Set0.bin i\<up> (UNIV::Inst Set.set)\<up>) (EB_Log0.beq (EB_Rel.bfunimg Inst2ImmDataShort\<up> i\<up>) (EB_Rel.bfunimg Inst2ImmData\<up> i\<up>))))"
assumes "hyp_102": "T (EB_Set0.bin Inst2ImmDataLong\<up> (EB_Rel.btfun (UNIV::Inst Set.set)\<up> DataLong\<up>))"
assumes "hyp_103": "T (\<forall>^ (i::Inst). (EB_Log.bimp (EB_Set0.bin i\<up> (UNIV::Inst Set.set)\<up>) (EB_Log0.beq (EB_Rel.bfunimg Inst2ImmDataLong\<up> i\<up>) (EB_Rel.bfunimg Inst2ImmData\<up> i\<up>))))"
assumes "hyp_104": "T (EB_Set0.bin Inst2SrcIndex\<up> (EB_Rel.btfun (UNIV::Inst Set.set)\<up> (EB_Int.bnat)))"
assumes "hyp_105": "T (EB_Set0.bin Inst2Src2Index\<up> (EB_Rel.btfun (UNIV::Inst Set.set)\<up> (EB_Int.bnat)))"
assumes "hyp_106": "T (EB_Set0.bin Inst2DstIndex\<up> (EB_Rel.btfun (UNIV::Inst Set.set)\<up> (EB_Int.bnat)))"
assumes "hyp_107": "T (EB_Set.bsubseteq DataInt\<up> (EB_Int.bintg))"
assumes "hyp_108": "T (EB_Set0.bin Data2Int\<up> (EB_Rel.btfun (UNIV::Data Set.set)\<up> DataInt\<up>))"
assumes "hyp_109": "T (EB_Set0.bin Int2Data\<up> (EB_Rel.btfun DataInt\<up> (UNIV::Data Set.set)\<up>))"
assumes "hyp_110": "T (EB_Set0.bin MaxVector\<up> (EB_Int.bnatn))"
assumes "hyp_111": "T (EB_Log0.beq InstArrayDom\<up> (EB_Int.bupto (1::int)\<up> MaxVector\<up>))"
assumes "hyp_112": "T (EB_Log.bnoteq InstArrayDom\<up> (EB_Set.bemptyset :: Int.int Set.set\<up>))"
assumes "hyp_113": "T (EB_Set0.bin MinMemPointer\<up> (EB_Int.bnat))"
assumes "hyp_114": "T (EB_Set0.bin MaxMemPointer\<up> (EB_Int.bnat))"
assumes "hyp_115": "T (EB_Int0.bleq MinMemPointer\<up> MaxMemPointer\<up>)"
assumes "hyp_116": "T (EB_Log0.beq MemArrayDom\<up> (EB_Int.bupto MinMemPointer\<up> MaxMemPointer\<up>))"
assumes "hyp_117": "T (EB_Log.bnoteq MemArrayDom\<up> (EB_Set.bemptyset :: Int.int Set.set\<up>))"
assumes "hyp_118": "T (EB_Log0.beq DataLongInt\<up> DataInt\<up>)"
assumes "hyp_119": "T (EB_Set0.bin Int2DataLong\<up> (EB_Rel.btfun DataLongInt\<up> DataLong\<up>))"
assumes "hyp_120": "T (\<forall>^ (x::Int.int). (EB_Log.bimp (EB_Set0.bin x\<up> DataLongInt\<up>) (EB_Log0.beq (EB_Rel.bfunimg Int2DataLong\<up> x\<up>) (EB_Rel.bfunimg Int2Data\<up> x\<up>))))"
assumes "hyp_121": "T (EB_Set0.bin DataLong2Int\<up> (EB_Rel.btfun DataLong\<up> DataLongInt\<up>))"
assumes "hyp_122": "T (\<forall>^ (x::Data). (EB_Log.bimp (EB_Set0.bin x\<up> DataLong\<up>) (EB_Log0.beq (EB_Rel.bfunimg DataLong2Int\<up> x\<up>) (EB_Rel.bfunimg Data2Int\<up> x\<up>))))"
assumes "hyp_123": "T (EB_Set.bsubseteq DataByteInt\<up> DataLongInt\<up>)"
assumes "hyp_124": "T (EB_Set0.bin Int2DataByte\<up> (EB_Rel.btfun DataByteInt\<up> DataByte\<up>))"
assumes "hyp_125": "T (\<forall>^ (x::Int.int). (EB_Log.bimp (EB_Set0.bin x\<up> DataByteInt\<up>) (EB_Log0.beq (EB_Rel.bfunimg Int2DataByte\<up> x\<up>) (EB_Rel.bfunimg Int2Data\<up> x\<up>))))"
assumes "hyp_126": "T (EB_Set0.bin DataByte2Int\<up> (EB_Rel.btfun DataByte\<up> DataByteInt\<up>))"
assumes "hyp_127": "T (\<forall>^ (x::Data). (EB_Log.bimp (EB_Set0.bin x\<up> DataByte\<up>) (EB_Log0.beq (EB_Rel.bfunimg DataByte2Int\<up> x\<up>) (EB_Rel.bfunimg Data2Int\<up> x\<up>))))"
assumes "hyp_128": "T (EB_Set0.bin MinRegIndex\<up> (EB_Int.bnat))"
assumes "hyp_129": "T (EB_Set0.bin MaxRegIndex\<up> (EB_Int.bnat))"
assumes "hyp_130": "T (EB_Int0.bleq MinRegIndex\<up> MaxRegIndex\<up>)"
assumes "hyp_131": "T (EB_Log0.beq RegArrayDom\<up> (EB_Int.bupto MinRegIndex\<up> MaxRegIndex\<up>))"
assumes "hyp_132": "T (EB_Log.bnoteq RegArrayDom\<up> (EB_Set.bemptyset :: Int.int Set.set\<up>))"
assumes "hyp_133": "T (EB_Set0.bin inst\<up> (UNIV::Inst Set.set)\<up>)"
assumes "hyp_134": "T (EB_Set0.bin status\<up> (UNIV::Status Set.set)\<up>)"
assumes "hyp_135": "T (EB_Set0.bin instArray\<up> (EB_Rel.btfun InstArrayDom\<up> (UNIV::Inst Set.set)\<up>))"
assumes "hyp_136": "T (EB_Set0.bin instPtr\<up> InstArrayDom\<up>)"
assumes "hyp_137": "T (EB_Log0.beq inst\<up> (EB_Rel.bfunimg instArray\<up> instPtr\<up>))"
assumes "hyp_138": "T (EB_Set0.bin instPtr\<up> (EB_Rel.bdom instArray\<up>))"
assumes "hyp_139": "T (EB_Set0.bin instArray\<up> (EB_Rel.bpfun (EB_Int.bintg) (UNIV::Inst Set.set)\<up>))"
assumes "hyp_140": "T (EB_Set0.bin regArray\<up> (EB_Rel.btfun RegArrayDom\<up> (UNIV::Data Set.set)\<up>))"
assumes "hyp_141": "T (EB_Set0.bin (EB_Rel.bfunimg instArray\<up> instPtr\<up>) (EB_Rel.bdom Inst2SrcIndex\<up>))"
assumes "hyp_142": "T (EB_Set0.bin (EB_Rel.bfunimg instArray\<up> instPtr\<up>) (EB_Rel.bdom Inst2DstIndex\<up>))"
assumes "hyp_143": "T (EB_Set0.bin memArray\<up> (EB_Rel.btfun MemArrayDom\<up> (UNIV::Data Set.set)\<up>))"
assumes "hyp_144": "T (EB_Set0.bin regArrayDataLong\<up> (EB_Rel.btfun RegArrayDom\<up> DataLong\<up>))"
assumes "hyp_145": "T (EB_Set0.bin memArrayDataLong\<up> (EB_Rel.btfun MemArrayDom\<up> DataLong\<up>))"
assumes "hyp_146": "T (\<forall>^ (i::Int.int). (EB_Log.bimp (EB_Set0.bin i\<up> RegArrayDom\<up>) (EB_Log0.beq (EB_Rel.bfunimg regArray\<up> i\<up>) (EB_Rel.bfunimg regArrayDataLong\<up> i\<up>))))"
assumes "hyp_147": "T (\<forall>^ (i::Int.int). (EB_Log.bimp (EB_Set0.bin i\<up> MemArrayDom\<up>) (EB_Log0.beq (EB_Rel.bfunimg memArray\<up> i\<up>) (EB_Rel.bfunimg memArrayDataLong\<up> i\<up>))))"
assumes "hyp_148": "T (EB_Set0.bin (EB_Rel.bfunimg instArray\<up> instPtr\<up>) (UNIV::Inst Set.set)\<up>)"
assumes "hyp_149": "T (EB_Set0.bin (EB_Rel.bfunimg instArray\<up> instPtr\<up>) DualOpInst\<up>)"
assumes "hyp_150": "T (EB_Set0.bin (instPtr\<up> .+. DualOpInstSize\<up>) InstArrayDom\<up>)"
assumes "hyp_151": "T (EB_Log0.beq status\<up> RUNNING\<up>)"
assumes "hyp_152": "T (EB_Log0.beq instr\<up> (EB_Rel.bfunimg instArray\<up> instPtr\<up>))"
assumes "hyp_153": "T (EB_Log0.beq op1Index\<up> (EB_Rel.bfunimg Inst2SrcIndex\<up> instr\<up>))"
assumes "hyp_154": "T (EB_Set0.bin instr\<up> (EB_Rel.bdom Inst2SrcIndex\<up>))"
assumes "hyp_155": "T (EB_Set0.bin Inst2SrcIndex\<up> (EB_Rel.bpfun (UNIV::Inst Set.set)\<up> (EB_Int.bintg)))"
assumes "hyp_156": "T (EB_Set0.bin op1Index\<up> RegArrayDom\<up>)"
assumes "hyp_157": "T (EB_Log0.beq op1Data\<up> (EB_Rel.bfunimg regArrayDataLong\<up> op1Index\<up>))"
assumes "hyp_158": "T (EB_Set0.bin op1Index\<up> (EB_Rel.bdom regArrayDataLong\<up>))"
assumes "hyp_159": "T (EB_Set0.bin regArrayDataLong\<up> (EB_Rel.bpfun (EB_Int.bintg) (UNIV::Data Set.set)\<up>))"
assumes "hyp_160": "T (EB_Log0.beq op2Index\<up> (EB_Rel.bfunimg Inst2Src2Index\<up> instr\<up>))"
assumes "hyp_161": "T (EB_Set0.bin instr\<up> (EB_Rel.bdom Inst2Src2Index\<up>))"
assumes "hyp_162": "T (EB_Set0.bin Inst2Src2Index\<up> (EB_Rel.bpfun (UNIV::Inst Set.set)\<up> (EB_Int.bintg)))"
assumes "hyp_163": "T (EB_Set0.bin op2Index\<up> RegArrayDom\<up>)"
assumes "hyp_164": "T (EB_Log0.beq op2Data\<up> (EB_Rel.bfunimg regArrayDataLong\<up> op2Index\<up>))"
assumes "hyp_165": "T (EB_Set0.bin op2Index\<up> (EB_Rel.bdom regArrayDataLong\<up>))"
assumes "hyp_166": "T (EB_Log0.beq (EB_Prod.bmapsto srcData\<up> funcOk\<up>) (EB_Rel.bfunimg DualOpFuncDataLong\<up> (EB_Prod.bmapsto op1Data\<up> op2Data\<up>)))"
assumes "hyp_167": "T (EB_Set0.bin (EB_Prod.bmapsto op1Data\<up> op2Data\<up>) (EB_Rel.bdom DualOpFuncDataLong\<up>))"
assumes "hyp_168": "T (EB_Set0.bin DualOpFuncDataLong\<up> (EB_Rel.bpfun (EB_Rel.bcprod (UNIV::Data Set.set)\<up> (UNIV::Data Set.set)\<up>) (EB_Rel.bcprod (UNIV::Data Set.set)\<up> (EB_Bool.bbool))))"
assumes "hyp_169": "T (EB_Log0.beq funcOk\<up> (EB_Log.btrue))"
assumes "hyp_170": "T (EB_Log0.beq dstIndex\<up> (EB_Rel.bfunimg Inst2DstIndex\<up> instr\<up>))"
assumes "hyp_171": "T (EB_Set0.bin instr\<up> (EB_Rel.bdom Inst2DstIndex\<up>))"
assumes "hyp_172": "T (EB_Set0.bin Inst2DstIndex\<up> (EB_Rel.bpfun (UNIV::Inst Set.set)\<up> (EB_Int.bintg)))"
assumes "hyp_173": "T (EB_Set0.bin dstIndex\<up> RegArrayDom\<up>)"
assumes "hyp_174": "T (EB_Set0.bin op1Index\<up> (EB_Rel.bdom regArray\<up>))"
assumes "hyp_175": "T (EB_Set0.bin regArray\<up> (EB_Rel.bpfun (EB_Int.bintg) (UNIV::Data Set.set)\<up>))"

locale "DualOpOk_grd9_GRD_goal" = "DualOpOk_grd9_GRD_decls" +
assumes "goal": "\<not> F (EB_Log0.beq op1Data\<up> (EB_Rel.bfunimg regArray\<up> op1Index\<up>))"

end
