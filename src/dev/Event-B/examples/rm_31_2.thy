(* File containing proof obligations. Do not edit this file. *)
theory "rm_31_2" imports "~~/contrib/HOL-EventB/EventB" begin

typedecl "L"
typedecl "N"

definition "AUX17" :: "((N \<times> L) \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX17_def": "AUX17 = (\<lambda> n_net. (EB_Set0.bin n_net\<up> (EB_Rel.brel (EB_Rel.bcprod (UNIV::N Set.set)\<up> (UNIV::L Set.set)\<up>) (EB_Int.bnat))))"

definition "AUX8" :: "L Set.set => HOL.bool\<up>"
where
  "AUX8_def": "AUX8 = (\<lambda> NET. (EB_Set.bsubseteq NET\<up> (UNIV::L Set.set)\<up>))"

definition "AUX10" :: "(N \<times> L) Set.set => HOL.bool\<up>"
where
  "AUX10_def": "AUX10 = (\<lambda> l_net. (EB_Set0.bin l_net\<up> (EB_Rel.brel (UNIV::N Set.set)\<up> (UNIV::L Set.set)\<up>)))"

definition "AUX2" :: "HOL.bool\<up>"
where
  "AUX2_def": "AUX2 = ((EB_Int.bfinite (UNIV::N Set.set)\<up>))"

definition "AUX20" :: "(L \<times> Int.int) Set.set => (N \<times> L) Set.set => ((N \<times> L) \<times> Int.int) Set.set => (Int.int \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX20_def": "AUX20 = (\<lambda> age m_net_dn n_net parity. (\<forall>^ (n::N) (l::L). (EB_Log.bimp ((EB_Set0.bin n\<up> (UNIV::N Set.set)\<up>) ^\<and>^ (EB_Set0.bin l\<up> (UNIV::L Set.set)\<up>)) (EB_Log.bequiv (EB_Set0.bin (EB_Prod.bmapsto n\<up> l\<up>) m_net_dn\<up>) ((EB_Set0.bin (EB_Prod.bmapsto (EB_Prod.bmapsto n\<up> l\<up>) (EB_Rel.bfunimg age\<up> l\<up>)) n_net\<up>) ^\<and>^ (EB_Log0.beq (EB_Rel.bfunimg parity\<up> (EB_Rel.bfunimg age\<up> l\<up>)) (0::int)\<up>))))))"

definition "AUX21" :: "((N \<times> L) \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX21_def": "AUX21 = (\<lambda> n_net. (EB_Int.bfinite n_net\<up>))"

definition "AUX12" :: "(N \<times> L) Set.set => HOL.bool\<up>"
where
  "AUX12_def": "AUX12 = (\<lambda> m_net_dn. (EB_Set0.bin m_net_dn\<up> (EB_Rel.brel (UNIV::N Set.set)\<up> (UNIV::L Set.set)\<up>)))"

definition "AUX30" :: "(L \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX30_def": "AUX30 = (\<lambda> age. (EB_Set0.bin age\<up> (EB_Rel.bpfun (UNIV::L Set.set)\<up> (EB_Int.bintg))))"

definition "AUX7" :: "(Int.int \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX7_def": "AUX7 = (\<lambda> parity. (\<forall>^ (n::Int.int). (EB_Log.bimp (EB_Set0.bin n\<up> (EB_Int.bnat)) (EB_Log0.beq (EB_Rel.bfunimg parity\<up> (n\<up> .+. (1::int)\<up>)) (EB_Int.bminus (1::int)\<up> (EB_Rel.bfunimg parity\<up> n\<up>))))))"

definition "AUX18" :: "((N \<times> L) \<times> Int.int) Set.set => (N \<times> L) Set.set => (Int.int \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX18_def": "AUX18 = (\<lambda> l_age l_net parity. (\<forall>^ (n::N) (l::L). (EB_Log.bimp ((EB_Set0.bin n\<up> (UNIV::N Set.set)\<up>) ^\<and>^ (EB_Set0.bin l\<up> (UNIV::L Set.set)\<up>)) (EB_Log.bequiv (EB_Set0.bin (EB_Prod.bmapsto n\<up> l\<up>) l_net\<up>) (EB_Log0.beq (EB_Rel.bfunimg parity\<up> (EB_Rel.bfunimg l_age\<up> (EB_Prod.bmapsto n\<up> l\<up>))) (1::int)\<up>)))))"

definition "AUX27" :: "N => HOL.bool\<up>"
where
  "AUX27_def": "AUX27 = (\<lambda> n. (EB_Set0.bin n\<up> (UNIV::N Set.set)\<up>))"

definition "AUX9" :: "L Set.set => HOL.bool\<up>"
where
  "AUX9_def": "AUX9 = (\<lambda> net. (EB_Set.bsubseteq net\<up> (UNIV::L Set.set)\<up>))"

definition "AUX3" :: "(Int.int \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX3_def": "AUX3 = (\<lambda> parity. (EB_Set0.bin parity\<up> (EB_Rel.btfun (EB_Int.bnat) {.(0::int)\<up>, (1::int)\<up>.})))"

definition "AUX22" :: "(L \<times> Int.int) Set.set => ((N \<times> L) \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX22_def": "AUX22 = (\<lambda> age n_net. (\<forall>^ (n::N) (l::L) (x::Int.int). (EB_Log.bimp (EB_Set0.bin (EB_Prod.bmapsto (EB_Prod.bmapsto n\<up> l\<up>) x\<up>) n_net\<up>) (EB_Int0.bleq x\<up> (EB_Rel.bfunimg age\<up> l\<up>)))))"

definition "AUX43" :: "(L \<times> Int.int) Set.set => L => HOL.bool\<up>"
where
  "AUX43_def": "AUX43 = (\<lambda> age l. ((EB_Set0.bin l\<up> (EB_Rel.bdom age\<up>)) ^\<and>^ (EB_Set0.bin age\<up> (EB_Rel.bpfun (UNIV::L Set.set)\<up> (EB_Int.bintg)))))"

definition "AUX24" :: "((N \<times> L) \<times> Int.int) Set.set => ((N \<times> L) \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX24_def": "AUX24 = (\<lambda> l_age n_net. (\<forall>^ (n::N) (l::L). (EB_Log.bimp ((EB_Set0.bin n\<up> (UNIV::N Set.set)\<up>) ^\<and>^ (EB_Set0.bin l\<up> (UNIV::L Set.set)\<up>)) (EB_Set.bnotin (EB_Prod.bmapsto (EB_Prod.bmapsto n\<up> l\<up>) (EB_Rel.bfunimg l_age\<up> (EB_Prod.bmapsto n\<up> l\<up>))) n_net\<up>))))"

definition "AUX49" :: "(Int.int \<times> Int.int) Set.set => Int.int => HOL.bool\<up>"
where
  "AUX49_def": "AUX49 = (\<lambda> parity x. (EB_Set0.bin x\<up> (EB_Rel.bdom parity\<up>)))"

definition "AUX16" :: "(L \<times> Int.int) Set.set => L Set.set => (Int.int \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX16_def": "AUX16 = (\<lambda> age net parity. (\<forall>^ (l::L). (EB_Log.bimp (EB_Set0.bin l\<up> (UNIV::L Set.set)\<up>) (EB_Log.bequiv (EB_Set0.bin l\<up> net\<up>) (EB_Log0.beq (EB_Rel.bfunimg parity\<up> (EB_Rel.bfunimg age\<up> l\<up>)) (1::int)\<up>)))))"

definition "AUX13" :: "(N \<times> L) Set.set => (N \<times> L) Set.set => HOL.bool\<up>"
where
  "AUX13_def": "AUX13 = (\<lambda> m_net_dn m_net_up. (EB_Log0.beq (m_net_up\<up> .\<inter>. m_net_dn\<up>) (EB_Set.bemptyset :: (N \<times> L) Set.set\<up>)))"

definition "AUX4" :: "(Int.int \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX4_def": "AUX4 = (\<lambda> parity. (EB_Log0.beq (EB_Rel.bfunimg parity\<up> (0::int)\<up>) (0::int)\<up>))"

definition "AUX25" :: "(L \<times> Int.int) Set.set => ((N \<times> L) \<times> Int.int) Set.set => ((N \<times> L) \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX25_def": "AUX25 = (\<lambda> age l_age n_net. (\<forall>^ (n::N) (l::L) (x::Int.int). (EB_Log.bimp ((EB_Int.ble (EB_Rel.bfunimg l_age\<up> (EB_Prod.bmapsto n\<up> l\<up>)) x\<up>) ^\<and>^ (EB_Int0.bleq x\<up> (EB_Rel.bfunimg age\<up> l\<up>))) (EB_Set0.bin (EB_Prod.bmapsto (EB_Prod.bmapsto n\<up> l\<up>) x\<up>) n_net\<up>))))"

definition "AUX15" :: "((N \<times> L) \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX15_def": "AUX15 = (\<lambda> l_age. (EB_Set0.bin l_age\<up> (EB_Rel.btfun (EB_Rel.bcprod (UNIV::N Set.set)\<up> (UNIV::L Set.set)\<up>) (EB_Int.bnat))))"

definition "AUX11" :: "(N \<times> L) Set.set => HOL.bool\<up>"
where
  "AUX11_def": "AUX11 = (\<lambda> m_net_up. (EB_Set0.bin m_net_up\<up> (EB_Rel.brel (UNIV::N Set.set)\<up> (UNIV::L Set.set)\<up>)))"

definition "AUX31" :: "(L \<times> Int.int) Set.set => L => (Int.int \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX31_def": "AUX31 = (\<lambda> age l parity. (EB_Set0.bin (EB_Rel.bfunimg age\<up> l\<up>) (EB_Rel.bdom parity\<up>)))"

definition "AUX29" :: "(L \<times> Int.int) Set.set => L => HOL.bool\<up>"
where
  "AUX29_def": "AUX29 = (\<lambda> age l. (EB_Set0.bin l\<up> (EB_Rel.bdom age\<up>)))"

definition "AUX5" :: "(Int.int \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX5_def": "AUX5 = (\<lambda> parity. (EB_Set0.bin (0::int)\<up> (EB_Rel.bdom parity\<up>)))"

definition "AUX46" :: "L => N => ((N \<times> L) \<times> Int.int) Set.set => Int.int => HOL.bool\<up>"
where
  "AUX46_def": "AUX46 = (\<lambda> l n n_net x. (EB_Set0.bin (EB_Prod.bmapsto (EB_Prod.bmapsto n\<up> l\<up>) x\<up>) n_net\<up>))"

definition "AUX19" :: "(L \<times> Int.int) Set.set => (N \<times> L) Set.set => ((N \<times> L) \<times> Int.int) Set.set => (Int.int \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX19_def": "AUX19 = (\<lambda> age m_net_up n_net parity. (\<forall>^ (n::N) (l::L). (EB_Log.bimp ((EB_Set0.bin n\<up> (UNIV::N Set.set)\<up>) ^\<and>^ (EB_Set0.bin l\<up> (UNIV::L Set.set)\<up>)) (EB_Log.bequiv (EB_Set0.bin (EB_Prod.bmapsto n\<up> l\<up>) m_net_up\<up>) ((EB_Set0.bin (EB_Prod.bmapsto (EB_Prod.bmapsto n\<up> l\<up>) (EB_Rel.bfunimg age\<up> l\<up>)) n_net\<up>) ^\<and>^ (EB_Log0.beq (EB_Rel.bfunimg parity\<up> (EB_Rel.bfunimg age\<up> l\<up>)) (1::int)\<up>))))))"

definition "AUX28" :: "(L \<times> Int.int) Set.set => L => (Int.int \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX28_def": "AUX28 = (\<lambda> age l parity. (EB_Log0.beq (EB_Rel.bfunimg parity\<up> (EB_Rel.bfunimg age\<up> l\<up>)) (1::int)\<up>))"

definition "AUX48" :: "(Int.int \<times> Int.int) Set.set => Int.int => HOL.bool\<up>"
where
  "AUX48_def": "AUX48 = (\<lambda> parity x. (EB_Log0.beq (EB_Rel.bfunimg parity\<up> x\<up>) (1::int)\<up>))"

definition "AUX1" :: "HOL.bool\<up>"
where
  "AUX1_def": "AUX1 = ((EB_Int.bfinite (UNIV::L Set.set)\<up>))"

definition "AUX23" :: "(L \<times> Int.int) Set.set => ((N \<times> L) \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX23_def": "AUX23 = (\<lambda> age l_age. (\<forall>^ (n::N) (l::L). (EB_Int0.bleq (EB_Rel.bfunimg l_age\<up> (EB_Prod.bmapsto n\<up> l\<up>)) (EB_Rel.bfunimg age\<up> l\<up>))))"

definition "AUX26" :: "L Set.set => L => HOL.bool\<up>"
where
  "AUX26_def": "AUX26 = (\<lambda> NET l. (EB_Set.bnotin l\<up> NET\<up>))"

definition "AUX45" :: "(L \<times> Int.int) Set.set => L => Int.int => HOL.bool\<up>"
where
  "AUX45_def": "AUX45 = (\<lambda> age l x. (EB_Log0.beq x\<up> (EB_Rel.bfunimg age\<up> l\<up>)))"

definition "AUX14" :: "(L \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX14_def": "AUX14 = (\<lambda> age. (EB_Set0.bin age\<up> (EB_Rel.btfun (UNIV::L Set.set)\<up> (EB_Int.bnat))))"

definition "AUX6" :: "(Int.int \<times> Int.int) Set.set => HOL.bool\<up>"
where
  "AUX6_def": "AUX6 = (\<lambda> parity. (EB_Set0.bin parity\<up> (EB_Rel.bpfun (EB_Int.bintg) (EB_Int.bintg))))"

lemmas "AUX" =
"AUX17_def" "AUX8_def" "AUX10_def" "AUX2_def" "AUX20_def" "AUX21_def"
"AUX12_def" "AUX30_def" "AUX7_def" "AUX18_def" "AUX27_def" "AUX9_def" "AUX3_def"
"AUX22_def" "AUX43_def" "AUX24_def" "AUX49_def" "AUX16_def" "AUX13_def"
"AUX4_def" "AUX25_def" "AUX15_def" "AUX11_def" "AUX31_def" "AUX29_def"
"AUX5_def" "AUX46_def" "AUX19_def" "AUX28_def" "AUX48_def" "AUX1_def"
"AUX23_def" "AUX26_def" "AUX45_def" "AUX14_def" "AUX6_def"

locale "discover_dn_inv2_INV_decls" =
fixes "n" :: "N"
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "discover_dn_inv2_INV_hyps" = "discover_dn_inv2_INV_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"
assumes "hyp_25": "T (AUX26 NET l)"
assumes "hyp_26": "T (AUX27 n)"
assumes "hyp_27": "T (AUX28 age l parity)"
assumes "hyp_28": "T (AUX29 age l)"
assumes "hyp_29": "T (AUX30 age)"
assumes "hyp_30": "T (AUX31 age l parity)"

locale "discover_dn_inv2_INV_goal" = "discover_dn_inv2_INV_decls" +
assumes "goal": "\<not> F (EB_Set0.bin (l_age\<up> .<+. {.(EB_Prod.bmapsto (EB_Prod.bmapsto n\<up> l\<up>) ((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>)).}) (EB_Rel.btfun (EB_Rel.bcprod (UNIV::N Set.set)\<up> (UNIV::L Set.set)\<up>) (EB_Int.bnat)))"

locale "discover_dn_inv3_INV_decls" =
fixes "n" :: "N"
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "discover_dn_inv3_INV_hyps" = "discover_dn_inv3_INV_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"
assumes "hyp_25": "T (AUX26 NET l)"
assumes "hyp_26": "T (AUX27 n)"
assumes "hyp_27": "T (AUX28 age l parity)"
assumes "hyp_28": "T (AUX29 age l)"
assumes "hyp_29": "T (AUX30 age)"
assumes "hyp_30": "T (AUX31 age l parity)"

locale "discover_dn_inv3_INV_goal" = "discover_dn_inv3_INV_decls" +
assumes "goal": "\<not> F (\<forall>^ (l0::L). (EB_Log.bimp (EB_Set0.bin l0\<up> (UNIV::L Set.set)\<up>) (EB_Log.bequiv (EB_Set0.bin l0\<up> (EB_Set.bsetminus net\<up> {.l\<up>.})) (EB_Log0.beq (EB_Rel.bfunimg parity\<up> (EB_Rel.bfunimg (age\<up> .<+. {.(EB_Prod.bmapsto l\<up> ((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>)).}) l0\<up>)) (1::int)\<up>))))"

locale "discover_dn_inv4_INV_decls" =
fixes "n" :: "N"
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "discover_dn_inv4_INV_hyps" = "discover_dn_inv4_INV_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"
assumes "hyp_25": "T (AUX26 NET l)"
assumes "hyp_26": "T (AUX27 n)"
assumes "hyp_27": "T (AUX28 age l parity)"
assumes "hyp_28": "T (AUX29 age l)"
assumes "hyp_29": "T (AUX30 age)"
assumes "hyp_30": "T (AUX31 age l parity)"

locale "discover_dn_inv4_INV_goal" = "discover_dn_inv4_INV_decls" +
assumes "goal": "\<not> F (EB_Set0.bin (n_net\<up> .\<union>. (EB_Rel.bcprod (EB_Rel.bcprod (EB_Set.bsetminus (UNIV::N Set.set)\<up> {.n\<up>.}) {.l\<up>.}) {.((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>).})) (EB_Rel.brel (EB_Rel.bcprod (UNIV::N Set.set)\<up> (UNIV::L Set.set)\<up>) (EB_Int.bnat)))"

locale "discover_dn_inv5_INV_decls" =
fixes "n" :: "N"
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "discover_dn_inv5_INV_hyps" = "discover_dn_inv5_INV_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"
assumes "hyp_25": "T (AUX26 NET l)"
assumes "hyp_26": "T (AUX27 n)"
assumes "hyp_27": "T (AUX28 age l parity)"
assumes "hyp_28": "T (AUX29 age l)"
assumes "hyp_29": "T (AUX30 age)"
assumes "hyp_30": "T (AUX31 age l parity)"

locale "discover_dn_inv5_INV_goal" = "discover_dn_inv5_INV_decls" +
assumes "goal": "\<not> F (\<forall>^ (n0::N) (l0::L). (EB_Log.bimp ((EB_Set0.bin n0\<up> (UNIV::N Set.set)\<up>) ^\<and>^ (EB_Set0.bin l0\<up> (UNIV::L Set.set)\<up>)) (EB_Log.bequiv (EB_Set0.bin (EB_Prod.bmapsto n0\<up> l0\<up>) (EB_Set.bsetminus l_net\<up> {.(EB_Prod.bmapsto n\<up> l\<up>).})) (EB_Log0.beq (EB_Rel.bfunimg parity\<up> (EB_Rel.bfunimg (l_age\<up> .<+. {.(EB_Prod.bmapsto (EB_Prod.bmapsto n\<up> l\<up>) ((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>)).}) (EB_Prod.bmapsto n0\<up> l0\<up>))) (1::int)\<up>))))"

locale "discover_dn_inv6_INV_decls" =
fixes "n" :: "N"
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "discover_dn_inv6_INV_hyps" = "discover_dn_inv6_INV_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"
assumes "hyp_25": "T (AUX26 NET l)"
assumes "hyp_26": "T (AUX27 n)"
assumes "hyp_27": "T (AUX28 age l parity)"
assumes "hyp_28": "T (AUX29 age l)"
assumes "hyp_29": "T (AUX30 age)"
assumes "hyp_30": "T (AUX31 age l parity)"

locale "discover_dn_inv6_INV_goal" = "discover_dn_inv6_INV_decls" +
assumes "goal": "\<not> F (\<forall>^ (n0::N) (l0::L). (EB_Log.bimp ((EB_Set0.bin n0\<up> (UNIV::N Set.set)\<up>) ^\<and>^ (EB_Set0.bin l0\<up> (UNIV::L Set.set)\<up>)) (EB_Log.bequiv (EB_Set0.bin (EB_Prod.bmapsto n0\<up> l0\<up>) (EB_Set.bsetminus m_net_up\<up> (EB_Rel.bcprod (UNIV::N Set.set)\<up> {.l\<up>.}))) ((EB_Set0.bin (EB_Prod.bmapsto (EB_Prod.bmapsto n0\<up> l0\<up>) (EB_Rel.bfunimg (age\<up> .<+. {.(EB_Prod.bmapsto l\<up> ((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>)).}) l0\<up>)) (n_net\<up> .\<union>. (EB_Rel.bcprod (EB_Rel.bcprod (EB_Set.bsetminus (UNIV::N Set.set)\<up> {.n\<up>.}) {.l\<up>.}) {.((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>).}))) ^\<and>^ (EB_Log0.beq (EB_Rel.bfunimg parity\<up> (EB_Rel.bfunimg (age\<up> .<+. {.(EB_Prod.bmapsto l\<up> ((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>)).}) l0\<up>)) (1::int)\<up>)))))"

locale "discover_dn_inv7_INV_decls" =
fixes "n" :: "N"
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "discover_dn_inv7_INV_hyps" = "discover_dn_inv7_INV_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"
assumes "hyp_25": "T (AUX26 NET l)"
assumes "hyp_26": "T (AUX27 n)"
assumes "hyp_27": "T (AUX28 age l parity)"
assumes "hyp_28": "T (AUX29 age l)"
assumes "hyp_29": "T (AUX30 age)"
assumes "hyp_30": "T (AUX31 age l parity)"

locale "discover_dn_inv7_INV_goal" = "discover_dn_inv7_INV_decls" +
assumes "goal": "\<not> F (\<forall>^ (n0::N) (l0::L). (EB_Log.bimp ((EB_Set0.bin n0\<up> (UNIV::N Set.set)\<up>) ^\<and>^ (EB_Set0.bin l0\<up> (UNIV::L Set.set)\<up>)) (EB_Log.bequiv (EB_Set0.bin (EB_Prod.bmapsto n0\<up> l0\<up>) (m_net_dn\<up> .\<union>. (EB_Rel.bcprod (EB_Set.bsetminus (UNIV::N Set.set)\<up> {.n\<up>.}) {.l\<up>.}))) ((EB_Set0.bin (EB_Prod.bmapsto (EB_Prod.bmapsto n0\<up> l0\<up>) (EB_Rel.bfunimg (age\<up> .<+. {.(EB_Prod.bmapsto l\<up> ((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>)).}) l0\<up>)) (n_net\<up> .\<union>. (EB_Rel.bcprod (EB_Rel.bcprod (EB_Set.bsetminus (UNIV::N Set.set)\<up> {.n\<up>.}) {.l\<up>.}) {.((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>).}))) ^\<and>^ (EB_Log0.beq (EB_Rel.bfunimg parity\<up> (EB_Rel.bfunimg (age\<up> .<+. {.(EB_Prod.bmapsto l\<up> ((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>)).}) l0\<up>)) (0::int)\<up>)))))"

locale "discover_dn_inv8_INV_decls" =
fixes "n" :: "N"
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "discover_dn_inv8_INV_hyps" = "discover_dn_inv8_INV_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"
assumes "hyp_25": "T (AUX26 NET l)"
assumes "hyp_26": "T (AUX27 n)"
assumes "hyp_27": "T (AUX28 age l parity)"
assumes "hyp_28": "T (AUX29 age l)"
assumes "hyp_29": "T (AUX30 age)"
assumes "hyp_30": "T (AUX31 age l parity)"

locale "discover_dn_inv8_INV_goal" = "discover_dn_inv8_INV_decls" +
assumes "goal": "\<not> F (EB_Int.bfinite (n_net\<up> .\<union>. (EB_Rel.bcprod (EB_Rel.bcprod (EB_Set.bsetminus (UNIV::N Set.set)\<up> {.n\<up>.}) {.l\<up>.}) {.((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>).})))"

locale "discover_dn_inv9_INV_decls" =
fixes "n" :: "N"
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "discover_dn_inv9_INV_hyps" = "discover_dn_inv9_INV_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"
assumes "hyp_25": "T (AUX26 NET l)"
assumes "hyp_26": "T (AUX27 n)"
assumes "hyp_27": "T (AUX28 age l parity)"
assumes "hyp_28": "T (AUX29 age l)"
assumes "hyp_29": "T (AUX30 age)"
assumes "hyp_30": "T (AUX31 age l parity)"

locale "discover_dn_inv9_INV_goal" = "discover_dn_inv9_INV_decls" +
assumes "goal": "\<not> F (\<forall>^ (n0::N) (l0::L) (x::Int.int). (EB_Log.bimp (EB_Set0.bin (EB_Prod.bmapsto (EB_Prod.bmapsto n0\<up> l0\<up>) x\<up>) (n_net\<up> .\<union>. (EB_Rel.bcprod (EB_Rel.bcprod (EB_Set.bsetminus (UNIV::N Set.set)\<up> {.n\<up>.}) {.l\<up>.}) {.((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>).}))) (EB_Int0.bleq x\<up> (EB_Rel.bfunimg (age\<up> .<+. {.(EB_Prod.bmapsto l\<up> ((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>)).}) l0\<up>))))"

locale "discover_dn_inv10_INV_decls" =
fixes "n" :: "N"
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "discover_dn_inv10_INV_hyps" = "discover_dn_inv10_INV_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"
assumes "hyp_25": "T (AUX26 NET l)"
assumes "hyp_26": "T (AUX27 n)"
assumes "hyp_27": "T (AUX28 age l parity)"
assumes "hyp_28": "T (AUX29 age l)"
assumes "hyp_29": "T (AUX30 age)"
assumes "hyp_30": "T (AUX31 age l parity)"

locale "discover_dn_inv10_INV_goal" = "discover_dn_inv10_INV_decls" +
assumes "goal": "\<not> F (\<forall>^ (n0::N) (l0::L). (EB_Int0.bleq (EB_Rel.bfunimg (l_age\<up> .<+. {.(EB_Prod.bmapsto (EB_Prod.bmapsto n\<up> l\<up>) ((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>)).}) (EB_Prod.bmapsto n0\<up> l0\<up>)) (EB_Rel.bfunimg (age\<up> .<+. {.(EB_Prod.bmapsto l\<up> ((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>)).}) l0\<up>)))"

locale "discover_dn_inv11_INV_decls" =
fixes "n" :: "N"
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "discover_dn_inv11_INV_hyps" = "discover_dn_inv11_INV_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"
assumes "hyp_25": "T (AUX26 NET l)"
assumes "hyp_26": "T (AUX27 n)"
assumes "hyp_27": "T (AUX28 age l parity)"
assumes "hyp_28": "T (AUX29 age l)"
assumes "hyp_29": "T (AUX30 age)"
assumes "hyp_30": "T (AUX31 age l parity)"

locale "discover_dn_inv11_INV_goal" = "discover_dn_inv11_INV_decls" +
assumes "goal": "\<not> F (\<forall>^ (n0::N) (l0::L). (EB_Log.bimp ((EB_Set0.bin n0\<up> (UNIV::N Set.set)\<up>) ^\<and>^ (EB_Set0.bin l0\<up> (UNIV::L Set.set)\<up>)) (EB_Set.bnotin (EB_Prod.bmapsto (EB_Prod.bmapsto n0\<up> l0\<up>) (EB_Rel.bfunimg (l_age\<up> .<+. {.(EB_Prod.bmapsto (EB_Prod.bmapsto n\<up> l\<up>) ((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>)).}) (EB_Prod.bmapsto n0\<up> l0\<up>))) (n_net\<up> .\<union>. (EB_Rel.bcprod (EB_Rel.bcprod (EB_Set.bsetminus (UNIV::N Set.set)\<up> {.n\<up>.}) {.l\<up>.}) {.((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>).})))))"

locale "discover_dn_inv12_INV_decls" =
fixes "n" :: "N"
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "discover_dn_inv12_INV_hyps" = "discover_dn_inv12_INV_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"
assumes "hyp_25": "T (AUX26 NET l)"
assumes "hyp_26": "T (AUX27 n)"
assumes "hyp_27": "T (AUX28 age l parity)"
assumes "hyp_28": "T (AUX29 age l)"
assumes "hyp_29": "T (AUX30 age)"
assumes "hyp_30": "T (AUX31 age l parity)"

locale "discover_dn_inv12_INV_goal" = "discover_dn_inv12_INV_decls" +
assumes "goal": "\<not> F (\<forall>^ (n0::N) (l0::L) (x::Int.int). (EB_Log.bimp ((EB_Int.ble (EB_Rel.bfunimg (l_age\<up> .<+. {.(EB_Prod.bmapsto (EB_Prod.bmapsto n\<up> l\<up>) ((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>)).}) (EB_Prod.bmapsto n0\<up> l0\<up>)) x\<up>) ^\<and>^ (EB_Int0.bleq x\<up> (EB_Rel.bfunimg (age\<up> .<+. {.(EB_Prod.bmapsto l\<up> ((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>)).}) l0\<up>))) (EB_Set0.bin (EB_Prod.bmapsto (EB_Prod.bmapsto n0\<up> l0\<up>) x\<up>) (n_net\<up> .\<union>. (EB_Rel.bcprod (EB_Rel.bcprod (EB_Set.bsetminus (UNIV::N Set.set)\<up> {.n\<up>.}) {.l\<up>.}) {.((EB_Rel.bfunimg age\<up> l\<up>) .+. (1::int)\<up>).})))))"

locale "discover_dn_grd1_GRD_decls" =
fixes "n" :: "N"
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "discover_dn_grd1_GRD_hyps" = "discover_dn_grd1_GRD_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"
assumes "hyp_25": "T (AUX26 NET l)"
assumes "hyp_26": "T (AUX27 n)"
assumes "hyp_27": "T (AUX28 age l parity)"
assumes "hyp_28": "T (AUX29 age l)"
assumes "hyp_29": "T (AUX30 age)"
assumes "hyp_30": "T (AUX31 age l parity)"

locale "discover_dn_grd1_GRD_goal" = "discover_dn_grd1_GRD_decls" +
assumes "goal": "\<not> F (EB_Set0.bin l\<up> (EB_Set.bsetminus net\<up> NET\<up>))"

locale "discover_dn_act1_WD_decls" =
fixes "n" :: "N"
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "discover_dn_act1_WD_hyps" = "discover_dn_act1_WD_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"
assumes "hyp_25": "T (AUX26 NET l)"
assumes "hyp_26": "T (AUX27 n)"
assumes "hyp_27": "T (AUX28 age l parity)"
assumes "hyp_28": "T (AUX29 age l)"
assumes "hyp_29": "T (AUX30 age)"
assumes "hyp_30": "T (AUX31 age l parity)"

locale "discover_dn_act1_WD_goal" = "discover_dn_act1_WD_decls" +
assumes "goal": "\<not> F (AUX43 age l)"

locale "discover_dn_act2_WD_decls" =
fixes "n" :: "N"
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "discover_dn_act2_WD_hyps" = "discover_dn_act2_WD_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"
assumes "hyp_25": "T (AUX26 NET l)"
assumes "hyp_26": "T (AUX27 n)"
assumes "hyp_27": "T (AUX28 age l parity)"
assumes "hyp_28": "T (AUX29 age l)"
assumes "hyp_29": "T (AUX30 age)"
assumes "hyp_30": "T (AUX31 age l parity)"

locale "discover_dn_act2_WD_goal" = "discover_dn_act2_WD_decls" +
assumes "goal": "\<not> F (AUX43 age l)"

locale "discover_dn_act3_WD_decls" =
fixes "n" :: "N"
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "discover_dn_act3_WD_hyps" = "discover_dn_act3_WD_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"
assumes "hyp_25": "T (AUX26 NET l)"
assumes "hyp_26": "T (AUX27 n)"
assumes "hyp_27": "T (AUX28 age l parity)"
assumes "hyp_28": "T (AUX29 age l)"
assumes "hyp_29": "T (AUX30 age)"
assumes "hyp_30": "T (AUX31 age l parity)"

locale "discover_dn_act3_WD_goal" = "discover_dn_act3_WD_decls" +
assumes "goal": "\<not> F (AUX43 age l)"

locale "change_link_up_grd1_WD_decls" =
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "change_link_up_grd1_WD_hyps" = "change_link_up_grd1_WD_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"

locale "change_link_up_grd1_WD_goal" = "change_link_up_grd1_WD_decls" +
assumes "goal": "\<not> F (AUX43 age l)"

locale "change_link_up_grd3_WD_decls" =
fixes "n" :: "N"
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "x" :: "Int.int"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "change_link_up_grd3_WD_hyps" = "change_link_up_grd3_WD_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"
assumes "hyp_25": "T (AUX45 age l x)"
assumes "hyp_26": "T (AUX29 age l)"
assumes "hyp_27": "T (AUX30 age)"
assumes "hyp_28": "T (AUX46 l n n_net x)"

locale "change_link_up_grd3_WD_goal" = "change_link_up_grd3_WD_decls" +
assumes "goal": "\<not> F ((EB_Set0.bin x\<up> (EB_Rel.bdom parity\<up>)) ^\<and>^ (EB_Set0.bin parity\<up> (EB_Rel.bpfun (EB_Int.bintg) (EB_Int.bintg))))"

locale "change_link_up_inv2_INV_decls" =
fixes "n" :: "N"
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "x" :: "Int.int"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "change_link_up_inv2_INV_hyps" = "change_link_up_inv2_INV_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"
assumes "hyp_25": "T (AUX45 age l x)"
assumes "hyp_26": "T (AUX29 age l)"
assumes "hyp_27": "T (AUX30 age)"
assumes "hyp_28": "T (AUX46 l n n_net x)"
assumes "hyp_29": "T (AUX48 parity x)"
assumes "hyp_30": "T (AUX49 parity x)"

locale "change_link_up_inv2_INV_goal" = "change_link_up_inv2_INV_decls" +
assumes "goal": "\<not> F (EB_Set0.bin (l_age\<up> .<+. {.(EB_Prod.bmapsto (EB_Prod.bmapsto n\<up> l\<up>) x\<up>).}) (EB_Rel.btfun (EB_Rel.bcprod (UNIV::N Set.set)\<up> (UNIV::L Set.set)\<up>) (EB_Int.bnat)))"

locale "change_link_up_inv4_INV_decls" =
fixes "n" :: "N"
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "x" :: "Int.int"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "change_link_up_inv4_INV_hyps" = "change_link_up_inv4_INV_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"
assumes "hyp_25": "T (AUX45 age l x)"
assumes "hyp_26": "T (AUX29 age l)"
assumes "hyp_27": "T (AUX30 age)"
assumes "hyp_28": "T (AUX46 l n n_net x)"
assumes "hyp_29": "T (AUX48 parity x)"
assumes "hyp_30": "T (AUX49 parity x)"

locale "change_link_up_inv4_INV_goal" = "change_link_up_inv4_INV_decls" +
assumes "goal": "\<not> F (EB_Set0.bin (EB_Set.bsetminus n_net\<up> {.(EB_Prod.bmapsto (EB_Prod.bmapsto n\<up> l\<up>) x\<up>).}) (EB_Rel.brel (EB_Rel.bcprod (UNIV::N Set.set)\<up> (UNIV::L Set.set)\<up>) (EB_Int.bnat)))"

locale "change_link_up_inv5_INV_decls" =
fixes "n" :: "N"
fixes "l_net" :: "(N \<times> L) Set.set"
fixes "n_net" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "l" :: "L"
fixes "l_age" :: "((N \<times> L) \<times> Int.int) Set.set"
fixes "age" :: "(L \<times> Int.int) Set.set"
fixes "m_net_dn" :: "(N \<times> L) Set.set"
fixes "NET" :: "L Set.set"
fixes "m_net_up" :: "(N \<times> L) Set.set"
fixes "x" :: "Int.int"
fixes "net" :: "L Set.set"
fixes "parity" :: "(Int.int \<times> Int.int) Set.set"

locale "change_link_up_inv5_INV_hyps" = "change_link_up_inv5_INV_decls" +
assumes "hyp_0": "T (AUX1)"
assumes "hyp_1": "T (AUX2)"
assumes "hyp_2": "T (AUX3 parity)"
assumes "hyp_3": "T (AUX4 parity)"
assumes "hyp_4": "T (AUX5 parity)"
assumes "hyp_5": "T (AUX6 parity)"
assumes "hyp_6": "T (AUX7 parity)"
assumes "hyp_7": "T (AUX8 NET)"
assumes "hyp_8": "T (AUX9 net)"
assumes "hyp_9": "T (AUX10 l_net)"
assumes "hyp_10": "T (AUX11 m_net_up)"
assumes "hyp_11": "T (AUX12 m_net_dn)"
assumes "hyp_12": "T (AUX13 m_net_dn m_net_up)"
assumes "hyp_13": "T (AUX14 age)"
assumes "hyp_14": "T (AUX15 l_age)"
assumes "hyp_15": "T (AUX16 age net parity)"
assumes "hyp_16": "T (AUX17 n_net)"
assumes "hyp_17": "T (AUX18 l_age l_net parity)"
assumes "hyp_18": "T (AUX19 age m_net_up n_net parity)"
assumes "hyp_19": "T (AUX20 age m_net_dn n_net parity)"
assumes "hyp_20": "T (AUX21 n_net)"
assumes "hyp_21": "T (AUX22 age n_net)"
assumes "hyp_22": "T (AUX23 age l_age)"
assumes "hyp_23": "T (AUX24 l_age n_net)"
assumes "hyp_24": "T (AUX25 age l_age n_net)"
assumes "hyp_25": "T (AUX45 age l x)"
assumes "hyp_26": "T (AUX29 age l)"
assumes "hyp_27": "T (AUX30 age)"
assumes "hyp_28": "T (AUX46 l n n_net x)"
assumes "hyp_29": "T (AUX48 parity x)"
assumes "hyp_30": "T (AUX49 parity x)"

locale "change_link_up_inv5_INV_goal" = "change_link_up_inv5_INV_decls" +
assumes "goal": "\<not> F (\<forall>^ (n0::N) (l0::L). (EB_Log.bimp ((EB_Set0.bin n0\<up> (UNIV::N Set.set)\<up>) ^\<and>^ (EB_Set0.bin l0\<up> (UNIV::L Set.set)\<up>)) (EB_Log.bequiv (EB_Set0.bin (EB_Prod.bmapsto n0\<up> l0\<up>) (l_net\<up> .\<union>. {.(EB_Prod.bmapsto n\<up> l\<up>).})) (EB_Log0.beq (EB_Rel.bfunimg parity\<up> (EB_Rel.bfunimg (l_age\<up> .<+. {.(EB_Prod.bmapsto (EB_Prod.bmapsto n\<up> l\<up>) x\<up>).}) (EB_Prod.bmapsto n0\<up> l0\<up>))) (1::int)\<up>))))"

end
