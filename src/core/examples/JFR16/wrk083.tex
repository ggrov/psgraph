\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
%\usepackage{amsmath} % breaks the index!
\ftlinepenalty=9999
\usepackage{A4}
\makeindex
\title{Mathematical Case Studies: Tools}
\author{Rob Arthan}
%\makeindex
\author{R.D. Arthan \\ Lemma 1 Ltd. \\ rda@lemma-one.com}
\date{\FormatDate{$Date: 2012/06/05 12:35:44 $%
}}

\def\Func#1{\mathsf{#1}}
\def\I{\Func{I}}
\def\K{\Func{K}}
\def\Uncurry{\Func{Uncurry}}
\def\Frees{\Func{frees}}
\def\Constant{\Func{Constant}}
\def\Unary{\Func{Unary}}
\def\Binary{\Func{Binary}}
\def\Parametrized{\Func{Parametrized}}
\def\To{\rightarrow}

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}

This document describes some tools that are used in the proofs in the {\Product} Mathematical Case Studies.
\end{abstract}
\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd \number\year \\
Reference: LEMMA1/HOL/WRK083; issue 1.115%


\end{centering}
\thispagestyle{empty}
\end{titlepage}
\newpage
\addtocounter{page}{1}
%\section{DOCUMENT CONTROL}
%\subsection{Contents list}
\tableofcontents
%\newpage
%\subsection{Document cross references}
\newpage
\subsection*{To Do}
\begin{itemize}

\item
Think through the packaging of the tools
\item
Add more powerful tools.
\end{itemize}


\bibliographystyle{plain}
\bibliography{fmu}

%%%%
%%%%
%%%%
%%%%
\newpage
\section{INTRODUCTION}
Currently the tools describes some utilities primarily for use in the code of the tools themselves and simple support for proving that an expression denotes a morphism in a concrete category finitely generated by certain given morphism constructors and object constructors.
%%%%
%%%%
\section{UTILITIES}
\begin{GFT}{SML}
\+fun \PrNL{}thm\_frees\PrNN{} (thm : THM) : TERM list = (\\
\+	frees (list\_mk\_\PrLB{} (concl thm :: asms thm))\\
\+);\\
\end{GFT}
\begin{GFT}{SML}
\+new\_error\_message\{id = 999001,\\
\+	text = "?0 is not of form ?1"\};\\
\+new\_error\_message\{id = 999002,\\
\+	text = "?0 expects a ?1-element argument list"\};\\
\+new\_error\_message\{id = 999003,\\
\+	text = "hd2 expects a list with at least 2 elements"\};\\
\+fun \PrNL{}dest\_any\PrNN{} (pattern : TERM, fun\_name : string) : TERM -> TERM list = (\\
\+	let	val (f, args) = strip\_app pattern;\\
\+		val arity = length args;\\
\+		fun strip\_and\_check tm = (\\
\+			let	val (g, args) = strip\_app tm;\\
\+				val \_ = term\_match g f;\\
\+			in	if	length args = arity\\
\+				then	args\\
\+				else	fail "" 0 []\\
\+			end	handle Fail \_ => (\\
\+				term\_fail fun\_name 999001 [tm, pattern]\\
\+			)\\
\+		);\\
\+	in	strip\_and\_check\\
\+	end\\
\+);\\
\end{GFT}
\begin{GFT}{SML}
\+fun \PrNL{}is\_any\PrNN{} (pattern : TERM) : TERM -> bool = (\\
\+	let	val dest = dest\_any (pattern, "is\_any");\\
\+	in	fn tm => (dest tm; true) handle Fail \_ => false\\
\+	end\\
\+);\\
\end{GFT}
\begin{GFT}{SML}
\+fun \PrNL{}mk\_any\PrNN{} (pattern : TERM, fun\_name : string) : TERM list -> TERM = (\\
\+	let	val (f, args) = strip\_app pattern;\\
\+		val arity\_s = string\_of\_int (length args);\\
\+		val ftys = map type\_of args;\\
\+		fun match\_arg\_tys i (aty :: more\_atys) (fty :: more\_ftys) = (\\
\+			let	val i = type\_match1 i aty fty;\\
\+			in	match\_arg\_tys i more\_atys more\_ftys\\
\+			end\\
\+		) | match\_arg\_tys i [] [] = (i\\
\+		) | match\_arg\_tys \_ \_ \_ = (\\
\+			fail fun\_name 999002 [fn () => arity\_s]\\
\+		);\\
\+		fun match\_and\_apply tms = (\\
\+			let	val atys = map type\_of tms;\\
\+				val i = match\_arg\_tys [] atys ftys;\\
\+				val f' = inst [] i f;\\
\+			in	list\_mk\_app (f', tms)\\
\+			end\\
\+		);\\
\+	in	match\_and\_apply\\
\+	end\\
\+);\\
\+fun \PrNL{}hd2\PrNN{} (x :: y :: \_ : 'a list) : 'a * 'a = (x, y)\\
\+|   hd2 \_ = fail "hd2" 999003 [];\\
\end{GFT}
\begin{GFT}{SML}
\+local \\
\+	val old\_thy = get\_current\_theory\_name();\\
\+	val \_ = open\_theory"combin";\\
\+	val \_ = push\_pc"basic\_hol1";\\
\+in\\
\+val \PrNL{}mk\_o\PrNN{} : TERM * TERM -> TERM = (\\
\+	let	val mk = mk\_any (\PrKM{}(t1 : 'b \PrKN{} 'c) o (t2 : 'a \PrKN{} 'b)\PrKO{}, "mk\_o");\\
\+	in	fn (t1, t2) => mk [t1, t2]\\
\+	end\\
\+);\\
\+val \PrNL{}dest\_o\PrNN{} : TERM -> TERM * TERM = (\\
\+	let	val dest = dest\_any (\PrKM{}(t1 : 'b \PrKN{} 'c) o (t2 : 'a \PrKN{} 'b)\PrKO{}, "mk\_o");\\
\+	in	hd2 o dest\\
\+	end\\
\+);\\
\+val \PrNL{}is\_o\PrNN{} : TERM -> bool = is\_any \PrKM{}(t1 : 'b \PrKN{} 'c) o (t2 : 'a \PrKN{} 'b)\PrKO{};\\
\+val \_ = open\_theory old\_thy;\\
\+end;\\
\end{GFT}
\section{PROVING MORPHISMHOOD}
%%%%
%%%%
\subsection{Representing $\lambda$-abstractions using first-order combinators}

\subsubsection{The approach: a rewrite system}

We assume given a set of unary operators, binary operators and
parametrized operators (such $x^n$ viewed as an operator on $x$ parametrized by $n$) that are primitive morphisms in some concrete category of interest.
We expect the projections $\pi_i : X_1 \times X_2 \To X_i$ to be included amongst the unary operators.
We also assume give some set of constant elements of selected objects
in the category.

We want to convert a $\lambda$-abstraction whose body is a first-order formula built using the given operators, constants and the pairing operator $\_, \_)$ into an equivalent function expressed using the combinators of a category with binary products.
We do this using the following rewrite system, where $V$ denotes a {\em variable structure}, i.e., $V$ is a pattern formed from variables using pairing (such that each free variable of $V$ appears exactly once in $V$).

\[
\begin{array}{rcl@{\quad\quad}l}
(\lambda V \bullet x) &\leadsto& \pi^V_x
	& \mbox{if $x \in \Frees(V)$} \\
(\lambda V \bullet y) &\leadsto& \K\,y
	& \mbox{if $y \not\in \Frees(V)$} \\
(\lambda V \bullet c) &\leadsto& \K\,c
	& \mbox{if $c \in \Constant$} \\
(\lambda V \bullet (t_1, t_2)) &\leadsto& \langle(\lambda V\bullet t_1), (\lambda V\bullet t_2)\rangle
	&  \\
(\lambda V \bullet f\,t) &\leadsto& f \circ (\lambda V\bullet t)
	& \mbox{if $f \in \Unary$} \\
(\lambda V \bullet g\,t_1\,t_2) &\leadsto& \Uncurry\,g \circ \langle(\lambda V\bullet t_1), (\lambda V\bullet t_2)\rangle
	& \mbox{if $g \in \Binary$} \\
(\lambda V \bullet h\,t\,p) &\leadsto& (\lambda x\bullet h\,x\,p) \circ (\lambda V\bullet t)
	& \mbox{if $h \in \Parametrized$} \\
\end{array}
\]

Here, if $V$ is a varstruct with a free occurrence of the variable $x$,
$\pi^V_x$ denotes the combination of projections which extracts $x$.
For example $\pi^{((z, x), y)}_x$ is $\pi_2 \circ \pi_1$.
As a special case, $\pi^x_x = \I$ and we may simplify $f \circ I$ to $f$.

%Note that if pairing is implemented by taking `,' to be a binary operator
%of type $\alpha \rightarrow \beta \rightarrow \alpha \times \beta$,
%the rule for pairing is subsumed by the rule for binary operators
%together with a simplification rule $\Upsilon (,) = \iota$.
\subsubsection{Implementation}

We prove template theorems that support the various clauses of the rewrite system.
\begin{GFT}{SML}
\+local \\
\+	val old\_thy = get\_current\_theory\_name();\\
\+	val \_ = open\_theory"combin";\\
\+	val \_ = push\_pc"basic\_hol1";\\
\+in\\
\+\\
\+val \PrNL{}i\_rule\_thm\PrNN{} = snd ("i\_rule\_thm", (\\
\+set\_goal([], \PrKM{}(\PrMM{}x\PrLH{} x) = CombI\PrKO{});\\
\+a(rewrite\_tac [get\_spec\PrKM{}CombI\PrKO{}]);\\
\+pop\_thm()\\
\+));\\
\end{GFT}
%%%%

\begin{GFT}{SML}
\+val \PrNL{}o\_i\_rule\_thm\PrNN{} = snd ("o\_i\_rule\_thm", (\\
\+set\_goal([], \PrKM{}\PrLF{}f\PrLH{}f o CombI = f\PrKO{});\\
\+a(rewrite\_tac [get\_spec\PrKM{}CombI\PrKO{}, get\_spec\PrKM{}\$o\PrKO{}]);\\
\+pop\_thm()\\
\+));\\
\end{GFT}
%%%%

\begin{GFT}{SML}
\+val \PrNL{}k\_rule\_thm\PrNN{} = snd ("k\_rule\_thm", (\\
\+set\_goal([], \PrKM{}\PrLF{}c\PrLH{} (\PrMM{}x\PrLH{} c) = CombK c\PrKO{});\\
\+a(rewrite\_tac [get\_spec\PrKM{}CombK\PrKO{}]);\\
\+pop\_thm()\\
\+));\\
\end{GFT}
%%%%

\begin{GFT}{SML}
\+val \PrNL{}unary\_rule\_thm\PrNN{} = snd ("unary\_rule\_thm", (\\
\+set\_goal([], \PrKM{} \PrLF{}f t\PrLH{} (\PrMM{}x\PrLH{}f (t x)) = f o t \PrKO{});\\
\+a(rewrite\_tac[o\_def]);\\
\+pop\_thm()\\
\+));\\
\end{GFT}
%%%%

\begin{GFT}{SML}
\+val \PrNL{}pair\_rule\_thm\PrNN{} = snd ("pair\_rule\_thm", (\\
\+set\_goal([], \PrKM{} \PrLF{}s t\PrLH{} (\PrMM{}x\PrLH{}(s x, t x)) = Pair(s, t)\PrKO{});\\
\+a(rewrite\_tac[pair\_def, o\_def, uncurry\_def]);\\
\+pop\_thm()\\
\+));\\
\end{GFT}
%%%%

\begin{GFT}{SML}
\+val \PrNL{}binary\_rule\_thm\PrNN{} = snd ("binary\_rule\_thm", (\\
\+set\_goal([], \PrKM{} \PrLF{}f s t\PrLH{} (\PrMM{}x\PrLH{}f (s x) (t x)) = Uncurry f o Pair(s, t)\PrKO{});\\
\+a(rewrite\_tac[pair\_def, o\_def, uncurry\_def]);\\
\+pop\_thm()\\
\+));\\
\end{GFT}
%%%%

\begin{GFT}{SML}
\+val \PrNL{}binary\_rule\_thm1\PrNN{} = snd ("binary\_rule\_thm1", (\\
\+set\_goal([], \PrKM{} \PrLF{}f c t\PrLH{} (\PrMM{}x\PrLH{}f c (t x)) = Uncurry f o Pair ((\PrMM{}x\PrLH{}c), t)\PrKO{});\\
\+a(rewrite\_tac[pair\_def, o\_def, uncurry\_def]);\\
\+pop\_thm()\\
\+));\\
\end{GFT}
%%%%
\begin{GFT}{SML}
\+val \PrNL{}parametrized\_rule\_thm\PrNN{} = snd ("parametrized\_rule\_thm", (\\
\+set\_goal([], \PrKM{} \PrLF{}f s p\PrLH{} (\PrMM{}x\PrLH{}f (s x) p) = (\PrMM{}x\PrLH{}f x p) o s\PrKO{});\\
\+a(rewrite\_tac[o\_def]);\\
\+pop\_thm()\\
\+));\\
\end{GFT}
\begin{GFT}{SML}
\+\\
\+val \PrMI{}\_expand\_thm : THM = prove\_rule[]\PrKM{}\PrLF{}f\PrLH{} f = \PrMM{}z\PrLH{} f z\PrKO{};\\
\+\\
\+val \_ = pop\_pc();\\
\+val \_ = open\_theory old\_thy;\\
\+end (* of local ... in ... end *);\\
\end{GFT}
%%%%
When we instantiate the template theorems, we want to rename type variables to avoid capture, we use the following utility to help with this.
\begin{GFT}{SML}
\+fun \PrNL{}list\_string\_variant\PrNN{} (avoid : string list) (ss : string list) : string list = (\\
\+	let	fun aux (s, (av, res)) = (\\
\+			let	val s' = string\_variant av s;\\
\+			in	(s'::av, s'::res)\\
\+			end\\
\+		);\\
\+	in	rev(snd (revfold aux ss (avoid, [])))\\
\+	end\\
\+);\\
\end{GFT}
%%%%
The derived rule 
\begin{INLINEFT}%
\+gen\_\PrLF{}\_elim\\
\end{INLINEFT}%
\ is \PrLF{}-elimination combined with renaming of type variables to avoid capture.
\begin{GFT}{SML}
\+fun \PrNL{}gen\_\PrLF{}\_elim\PrNN{} (tm : TERM) (thm : THM) : THM = (\\
\+	let	val tm\_tyvs = term\_tyvars tm;\\
\+		val (asms, conc) = dest\_thm thm;\\
\+		val thm\_tyvs = term\_tyvars (mk\_list(conc::asms));\\
\+		val thm\_tyvs' = list\_string\_variant tm\_tyvs thm\_tyvs;\\
\+		val thm' = inst\_type\_rule (combine (map mk\_vartype thm\_tyvs') (map mk\_vartype thm\_tyvs)) thm;\\
\+	in	\PrLF{}\_elim tm thm'\\
\+	end\\
\+);\\
\end{GFT}
The derived rule 
\begin{INLINEFT}%
\+all\_\PrLF{}\_intro1\\
\end{INLINEFT}%
\ gives the universal closure of a theorem but leaving the free variables
of a specified term that are not included in a supplied list of ``pattern variables'' free.

\begin{GFT}{SML}
\+fun \PrNL{}all\_\PrLF{}\_intro1\PrNN{} (pat\_vars : TERM list) (tm : TERM) (thm : THM) : THM = (\\
\+	let	val fvs = frees tm diff pat\_vars;\\
\+		val bvs = thm\_frees thm diff fvs;\\
\+	in	list\_\PrLF{}\_intro bvs thm\\
\+	end\\
\+);\\
\end{GFT}
%%%%
Now
\begin{INLINEFT}%
\+morphism\Backslash{}\_conv\\
\end{INLINEFT}%
\ implements our rewrite system.
\begin{GFT}{SML}
\+fun \PrNL{}morphism\_conv\PrNN{}\\
\+	\{unary : TERM list, binary : TERM list, parametrized : TERM list, pattern\_vars : TERM list\}\\
\+	: CONV = (\\
\+	let	val unary\_thms = map (fn t => all\_\PrLF{}\_intro1 pattern\_vars t (gen\_\PrLF{}\_elim t unary\_rule\_thm))\\
\+			unary;\\
\+		val binary\_thms = map (fn t => all\_\PrLF{}\_intro1 pattern\_vars t (gen\_\PrLF{}\_elim t binary\_rule\_thm))\\
\+			binary;\\
\+		val binary\_thms1 = map (fn t => all\_\PrLF{}\_intro1 pattern\_vars t (gen\_\PrLF{}\_elim t binary\_rule\_thm1))\\
\+			binary;\\
\+		val parametrized\_thms = map (switch gen\_\PrLF{}\_elim parametrized\_rule\_thm)\\
\+			parametrized;\\
\+		val i\_conv = simple\_eq\_match\_conv i\_rule\_thm;\\
\+		val k\_conv = simple\_eq\_match\_conv k\_rule\_thm;\\
\+		val pair\_conv = simple\_ho\_eq\_match\_conv pair\_rule\_thm;\\
\+		val unary\_conv = FIRST\_C (map simple\_ho\_eq\_match\_conv1 unary\_thms)\\
\+			handle Fail \_ => fail\_conv;\\
\+		val binary\_conv = FIRST\_C (map simple\_ho\_eq\_match\_conv1 (binary\_thms @ binary\_thms1))\\
\+			handle Fail \_ => fail\_conv;\\
\+		val parametrized\_conv = FIRST\_C (map simple\_ho\_eq\_match\_conv1 parametrized\_thms)\\
\+			handle Fail \_ => fail\_conv;\\
\+		val simp\_conv = simple\_eq\_match\_conv o\_i\_rule\_thm;\\
\+		val rec rec\_conv = (fn t =>\\
\+			((i\_conv ORELSE\_C\\
\+			k\_conv ORELSE\_C\\
\+			(pair\_conv THEN\_C RAND\_C(RANDS\_C(TRY\_C rec\_conv))) ORELSE\_C\\
\+			(unary\_conv THEN\_TRY\_C RIGHT\_C rec\_conv) ORELSE\_C\\
\+			(binary\_conv THEN\_C RIGHT\_C (RAND\_C(RANDS\_C (TRY\_C rec\_conv)))) ORELSE\_C\\
\+			(parametrized\_conv THEN\_C RIGHT\_C (TRY\_C rec\_conv)))\\
\+				AND\_OR\_C simp\_conv) t\\
\+		);\\
\+	in	\PrMM{}\_unpair\_conv AND\_OR\_C rec\_conv\\
\+	end\\
\+);\\
\end{GFT}
\subsection{Moprhismhood Tactic}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Now we build the basic morphismhood tactic.
It expects a goal of the form
\begin{INLINEFT}%
\+f \PrIN{} (X, Y) Morphism\\
\end{INLINEFT}%
.
The tactic begins by \PrMI{}-expanding $f$ if it not already an abstraction.
\begin{GFT}{SML}
\+\\
\+val  \PrNL{}\PrMI{}\_expand\_conv\PrNN{} : CONV = (fn tm => (\\
\+	if	is\_\PrMM{} tm\\
\+	then	fail\_conv\\
\+	else	simple\_eq\_match\_conv \PrMI{}\_expand\_thm) tm);\\
\+\\
\end{GFT}
The theorem is parametrized by a list of theorems that are used
as an initial set of rewrite rules. For convenience, we convert
any paired abstractions in these theorems into simple abstractions,
which makes them more general as rewrite rules.
\begin{GFT}{SML}
\+\\
\+val \PrNL{}unpair\_rewrite\_tac\PrNN{} : THM list -> TACTIC = \\
\+	rewrite\_tac o map (conv\_rule (TRY\_C (MAP\_C \PrMM{}\_unpair\_conv)));\\
\end{GFT}
Now the tactic. After the \PrMI{}-expansion and rewriting discussed above,
it converts the function into combinator form.
It then goes through a cycle of backchaining with implicative facts
applying the supplied tactic to guess
existential witnesses, then stripping and rewriting with the basic facts.
\begin{GFT}{SML}
\+fun \PrNL{}basic\_morphism\_tac\PrNN{}\\
\+	\{\\
\+		unary : TERM list,\\
\+		binary : TERM list,\\
\+		parametrized : TERM list,\\
\+		pattern\_vars : TERM list,\\
\+		facts : THM list,\\
\+		witness\_tac : TACTIC\} : THM list -> TACTIC = (\\
\+	let	val m\_conv = morphism\_conv \{\\
\+			unary = unary,\\
\+			binary = binary,\\
\+			parametrized = parametrized,\\
\+			pattern\_vars = pattern\_vars\};\\
\+		val is\_rule = is\_\PrLE{} o snd o strip\_\PrLF{} o concl;\\
\+		val rule\_thms = facts drop (not o is\_rule);\\
\+		val axiom\_thms = facts drop is\_rule;\\
\+	in	fn rw\_thms =>\\
\+			TRY (conv\_tac (LEFT\_C \PrMI{}\_expand\_conv))\\
\+		THEN	TRY (unpair\_rewrite\_tac rw\_thms)\\
\+		THEN	conv\_tac (LEFT\_C m\_conv)	\\
\+		THEN 	(REPEAT o CHANGED\_T) (\\
\+				(TRY o bc\_tac) rule\_thms\\
\+			THEN	TRY witness\_tac\\
\+			THEN	REPEAT strip\_tac\\
\+			THEN	(TRY o rewrite\_tac) axiom\_thms)\\
\+	end\\
\+);\\
\end{GFT}
The following constructs witnesses to objecthood using a supplied list of object constructors based on the type of the desired witness.
Each object constructor is given with a list of type variables that are not to be instantiated in the search for a witness.
\begin{GFT}{SML}
\+fun \PrNL{}object\_by\_type\PrNN{} (ocs : (string list * TERM) list) : TYPE -> TERM = (\\
\+	let	fun preprocess acc [] = acc\\
\+		|   preprocess acc ((tvs, oc) :: more) = (\\
\+			let	val rev\_tys = rev(strip\_\PrKN{}\_type (type\_of oc));\\
\+				val res\_ty = hd (rev\_tys);\\
\+				val tysubs0 = map (fn tv => (mk\_vartype tv, mk\_vartype tv)) tvs;\\
\+				val arg\_tys = rev (tl rev\_tys);\\
\+			in	preprocess ((res\_ty,  (oc, tysubs0, arg\_tys)) :: acc) more\\
\+			end\\
\+		);\\
\+		val table = preprocess [] ocs;\\
\+		fun solve [] ty = fail "object\_by\_type" 1005 []\\
\+		|   solve ((res\_ty, (oc, tysubs0, arg\_tys)) :: more) ty = (\\
\+			let	val recur = solve table;\\
\+				val tysubs = type\_match1 tysubs0 ty res\_ty;\\
\+				val args = map (recur o inst\_type tysubs) arg\_tys;\\
\+				val ioc = inst [] tysubs oc;\\
\+			in	list\_mk\_app(ioc, args)\\
\+			end	handle Fail \_ => solve more ty\\
\+		);\\
\+	in	solve table\\
\+	end\\
\+);\\
\end{GFT}
%%%%

In the following, the list of strings with each object constructor is a list of type variables that are not to be instantiated when matching with this constructor. Typically these would be type variables appearing in the type of something which is an object by dint of an assumption of the goal.

\begin{GFT}{SML}
\+fun \PrNL{}\PrLG{}\_object\_by\_type\_tac\PrNN{} (ocs : (string list * TERM) list) : TACTIC = (\\
\+	let	val witness\_by\_type = object\_by\_type ocs;\\
\+	in	fn gl as (\_, conc) => \\
\+		let	val (x, \_) = dest\_simple\_\PrLG{} conc;\\
\+		in	(simple\_\PrLG{}\_tac o witness\_by\_type o type\_of) x gl\\
\+		end\\
\+	end\\
\+);\\
\+(*\\
\end{GFT}
The following function that extracts lists of known unary, binary and parametrized morphisms and a list
of known objects from a list of theorems.
The patterns have the form $(v, t)$ where $v$ is a variable and $t$ is a term containing a free
occurrence of $v$ to be matched with the conclusion of a theorem.
If there is a match in the binary pattern, for example, the appropriate instanve of $v$ is added to the list
of binary morphisms.
\begin{GFT}{SML}
\+*)\\
\+fun \PrNL{}analyse\_morphism\_thms\PrNN{}\\
\+	\{object\_pat : TERM, unary\_pat : TERM, binary\_pat : TERM, parametrized\_pat : TERM\}\\
\+	: THM list ->\\
\+		\{unary : TERM list, binary : TERM list, parametrized : TERM list\} *\\
\+			(string list * TERM) list = (\\
\+	let	fun dp p = dest\_pair p handle Fail \_ => (mk\_t, mk\_t);\\
\+		val (object\_v, object\_p) = dp object\_pat;\\
\+		val (unary\_v, unary\_p) = dp unary\_pat;\\
\+		val (binary\_v, binary\_p) = dp binary\_pat;\\
\+		val (parametrized\_v, parametrized\_p) = dp parametrized\_pat;\\
\+		fun aux (accs as (acc\_u, acc\_b, acc\_p, acc\_o))\\
\+			((thm :: more)) = (\\
\+			let	val tm = (snd o strip\_\PrLF{} o concl) thm;\\
\+			in	let	val (tym, tmm) = term\_match tm binary\_p;\\
\+					val bin = subst tmm (inst [] tym binary\_v);\\
\+				in	aux (acc\_u, bin::acc\_b, acc\_p, acc\_o) more\\
\+				end	handle Fail \_ =>\\
\+				let	val (tym, tmm) = term\_match tm parametrized\_p;\\
\+					val par = subst tmm (inst [] tym parametrized\_v);\\
\+				in	aux (acc\_u, acc\_b, par::acc\_p, acc\_o) more\\
\+				end	handle Fail \_ =>\\
\+				let	val (tym, tmm) = term\_match tm unary\_p;\\
\+					val un = subst tmm (inst [] tym unary\_v);\\
\+				in	aux (un::acc\_u, acc\_b, acc\_p, acc\_o) more\\
\+				end	handle Fail \_ =>\\
\+				let	val (tym, tmm) = term\_match tm object\_p;\\
\+					val ob = subst tmm (inst [] tym object\_v);\\
\+					val tvs = (list\_cup o map term\_tyvars o asms) thm;\\
\+				in	aux (acc\_u, acc\_b, acc\_p, (tvs, ob)::acc\_o) more\\
\+				end	handle Fail \_ => aux accs more\\
\+			end\\
\+		) | aux accs [] = accs;\\
\+	in	fn thms => (\\
\+			let	val (ul, bl, pl, ol) = aux ([], [], [], []) thms;\\
\+			in	(\{unary = ul, binary = bl, parametrized = pl\}, ol)\\
\+			end\\
\+		)\\
\+	end\\
\+);\\
\+(*\\
\end{GFT}
The following gives a standard way of constructing the parameters for the morphismhood tactic.
\begin{GFT}{SML}
\+*)\\
\+fun morphism\_params\PrNN{}\\
\+	(pats as \{object\_pat : TERM, unary\_pat : TERM, binary\_pat : TERM, parametrized\_pat : TERM\})\\
\+	(fst\_snd : TERM list)\\
\+	(basic\_obs : (string list * TERM) list)\\
\+	(tac :  (string list * TERM) list -> TACTIC)\\
\+	(basic\_thms : THM list)\\
\+	(thms : THM list) :\\
\+	\{unary : TERM list,\\
\+	 binary : TERM list,\\
\+	 parametrized : TERM list,\\
\+	 pattern\_vars : TERM list,\\
\+	 facts : THM list,\\
\+	 witness\_tac : TACTIC\} = (\\
\+	let	val (\{unary, binary, parametrized\}, obs) = analyse\_morphism\_thms pats thms;\\
\+	in\\
\+		\{unary = fst\_snd @ unary,\\
\+		 binary = binary,\\
\+		 parametrized = parametrized,\\
\+		 pattern\_vars = [],\\
\+		 facts = thms @ basic\_thms,\\
\+		 witness\_tac = tac (basic\_obs @ obs)\}\\
\+	end\\
\+);\\
\+\\
\end{GFT}
\section{HIGHER-ORDER BACKCHAINING}

%%%%
%%%%
In the following, we have some choice about how much normalisation to do.
We need to do full $\beta$-$\eta$ normalisation to make sure the conclusion
of the goal matches the succedent of the instantiated theorem. However, we
just do $\beta$-normalisation of the antecedent to preserve the form of
subterms such as
\begin{INLINEFT}%
\+\PrMM{}i\PrLH{}n + i\\
\end{INLINEFT}%
.
\begin{GFT}{SML}
\+local\\
\+fun \PrNL{}bc\_rule\PrNN{} (th : THM) : THM = (\\
\+	let	val (ant, suc) = dest\_\PrLE{} (concl th);\\
\+		fun aux (v :: vs) a th = (\\
\+			let	val (a', th') = aux vs a th;\\
\+				val a'' = mk\_simple\_\PrLG{} (v, a');\\
\+				val th1 = asm\_rule a'';\\
\+				val th2 = simple\_\PrLG{}\_elim v th1 th';\\
\+			in	(a'', th2)\\
\+			end\\
\+		) | aux [] a th = (a, th);\\
\+	in	case frees ant term\_diff\\
\+		(flat(map frees(suc :: asms th))) of\\
\+		[] => th\\
\+		|	vs => (\\
\+			let	val (a,th1) = aux vs ant (undisch\_rule th);\\
\+				val th2 = \PrLE{}\_intro a th1;\\
\+			in	th2\\
\+			end\\
\+		)\\
\+	end\\
\+);\\
\+in\\
\+fun \PrNL{}ho\_bc\_thm\_tac\PrNN{} (thm : THM) : TACTIC = ( \\
\+	let	val thm0 = all\_\PrLF{}\_elim thm;\\
\+		val thm1 = all\_\PrLF{}\_intro(\\
\+			if	is\_\PrLE{}(concl thm0)\\
\+			then	thm0\\
\+			else	fst (\PrKE{}\_elim thm0))\\
\+			handle Fail \_ => thm\_fail "bc\_thm\_tac" 29012 [thm];\\
\+		val (bvs, \_) =  strip\_\PrLF{}(concl thm1);\\
\+	in\\
\+	fn gl as (\_, conc) =>\\
\+	let	val nbvs = list\_variant (frees conc) bvs;\\
\+		val thm2 = list\_\PrLF{}\_elim nbvs thm1;\\
\+		val (\_, suc) = dest\_\PrLE{}(concl thm2);\\
\+		val (tym, tmm) = simple\_ho\_match [] conc suc\\
\+			handle Fail \_ => term\_fail "bc\_thm\_tac" 29011 [suc];\\
\+		val thm3 = asm\_inst\_term\_rule tmm (asm\_inst\_type\_rule tym thm2);\\
\+		val thm4 = conv\_rule (TRY\_C\\
\+				(LEFT\_C all\_simple\_\PrMC{}\_conv AND\_OR\_C\\
\+					RIGHT\_C simple\_\PrMC{}\_\PrMI{}\_norm\_conv)) thm3;\\
\+		val thm5 = bc\_rule thm4;\\
\+	in	TRY (conv\_tac simple\_\PrMC{}\_\PrMI{}\_norm\_conv) THEN \PrLE{}\_thm\_tac thm5\\
\+	end	gl\\
\+	end\\
\+);\\
\+end;\\
\end{GFT}
\end{document}
