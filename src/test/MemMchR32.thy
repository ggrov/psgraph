(* File containing proof obligations. Do not edit this file. *)
theory "MemMchR32" imports "~~/contrib/HOL-EventB/EventB" begin

typedecl "Inst"
typedecl "Data"
typedecl "Status"

consts "Int2Data" :: "(Int.int \<times> Data) Set.set"
 "instArray" :: "(Int.int \<times> Inst) Set.set"
 "Inst2ImmDataLong" :: "(Inst \<times> Data) Set.set"
 "Inst2DstIndex" :: "(Inst \<times> Int.int) Set.set"
 "DataByte" :: "Data Set.set"
 "FetchImmInst" :: "Inst Set.set"
 "IncrInst" :: "Inst Set.set"
 "FetchMemInstSize" :: "Int.int"
 "MoveInst" :: "Inst Set.set"
 "Inst2Src2Index" :: "(Inst \<times> Int.int) Set.set"
 "FlowInst" :: "Inst Set.set"
 "ValidInst" :: "Inst Set.set"
 "DataLongSize" :: "Int.int"
 "MemWriteInstSize" :: "Int.int"
 "FetchMemInst" :: "Inst Set.set"
 "funcOk" :: "HOL.bool"
 "Int2DataLong" :: "(Int.int \<times> Data) Set.set"
 "op2Data" :: "Data"
 "DataShortSize" :: "Int.int"
 "JumpInst" :: "Inst Set.set"
 "FetchImmShortInst" :: "Inst Set.set"
 "NullInstSize" :: "Int.int"
  "Null2Inst" :: "Inst Set.set"
  "FetchImmByteInst" :: "Inst Set.set"
  "Inst2ImmData" :: "(Inst \<times> Data) Set.set"
  "RegWriteInst" :: "Inst Set.set"
  "FetchInst" :: "Inst Set.set"
  "DataShort" :: "Data Set.set"
  "op2Index" :: "Int.int"
  "inst" :: "Inst"
  "MaxVector" :: "Int.int"
  "MoveInstSize" :: "Int.int"
  "MaxRegIndex" :: "Int.int"
  "MaxMemPointer" :: "Int.int"
  "SingleOpFuncDataLong" :: "(Data \<times> (Data \<times> HOL.bool)) Set.set"
  "status" :: "Status"
  "NullInst" :: "Inst Set.set"
  "Int2DataByte" :: "(Int.int \<times> Data) Set.set"
  "dstIndex" :: "Int.int"
  "SingleOpInstSize" :: "Int.int"
  "FetchInstPtrInstSize" :: "Int.int"
  "FetchImmInstSize" :: "Int.int"
  "regArray" :: "(Int.int \<times> Data) Set.set"
  "instPtr" :: "Int.int"
  "DataByteInt" :: "Int.int Set.set"
  "Inst2SrcIndex" :: "(Inst \<times> Int.int) Set.set"
  "MemArrayDom" :: "Int.int Set.set"
  "FetchInstPtrInst" :: "Inst Set.set"
  "BranchInst" :: "Inst Set.set"
  "instr" :: "Inst"
  "InstArrayDom" :: "Int.int Set.set"
  "LOADING" :: "Status"
  "DualOpFunc" :: "((Data \<times> Data) \<times> (Data \<times> HOL.bool)) Set.set"
  "memArrayDataLong" :: "(Int.int \<times> Data) Set.set"
  "DataLongInt" :: "Int.int Set.set"
  "DataByte2Int" :: "(Data \<times> Int.int) Set.set"
  "DataLong" :: "Data Set.set"
  "FetchImmLongInst" :: "Inst Set.set"
  "regArrayDataLong" :: "(Int.int \<times> Data) Set.set"
  "MinMemPointer" :: "Int.int"
  "memArray" :: "(Int.int \<times> Data) Set.set"
  "InvalidInst" :: "Inst Set.set"
  "RegArrayDom" :: "Int.int Set.set"
  "srcData" :: "Data"
  "Inst2ImmDataByte" :: "(Inst \<times> Data) Set.set"
  "SingleOpFunc" :: "(Data \<times> (Data \<times> HOL.bool)) Set.set"
  "MinRegIndex" :: "Int.int"
  "op1Index" :: "Int.int"
  "DualOpInstSize" :: "Int.int"
  "RUNNING" :: "Status"
  "SingleOpInst" :: "Inst Set.set"
  "ExecInst" :: "Inst Set.set"
  "Inst2ImmDataShort" :: "(Inst \<times> Data) Set.set"
  "FAILED" :: "Status"
  "DataLong2Int" :: "(Data \<times> Int.int) Set.set"
  "DualOpFuncDataLong" :: "((Data \<times> Data) \<times> (Data \<times> HOL.bool)) Set.set"
  "DualOpInst" :: "Inst Set.set"
  "MemWriteInst" :: "Inst Set.set"
  "DataByteSize" :: "Int.int"
  "StopInst" :: "Inst Set.set"
  "HALTED" :: "Status"
  "op1Data" :: "Data"
  "DataInt" :: "Int.int Set.set"
  "Data2Int" :: "(Data \<times> Int.int) Set.set"

axioms "hyp_0": "T (EB_Log.bnoteq (UNIV::Inst Set.set)\<up> (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_1": "T (EB_Set.bsubseteq ValidInst\<up> (UNIV::Inst Set.set)\<up>)"
axioms "hyp_2": "T (EB_Log.bnoteq ValidInst\<up> (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_3": "T (EB_Set.bsubseteq InvalidInst\<up> (UNIV::Inst Set.set)\<up>)"
axioms "hyp_4": "T (EB_Log.bnoteq InvalidInst\<up> (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_5": "T (EB_Log0.beq (UNIV::Inst Set.set)\<up> (ValidInst\<up> .\<union>. InvalidInst\<up>))"
axioms "hyp_6": "T (EB_Log0.beq (ValidInst\<up> .\<inter>. InvalidInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_7": "T (EB_Set.bnsubseteq InvalidInst\<up> ValidInst\<up>)"
axioms "hyp_8": "T (EB_Set.bsubseteq ExecInst\<up> ValidInst\<up>)"
axioms "hyp_9": "T (EB_Log.bnoteq ExecInst\<up> (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_10": "T (EB_Set.bsubseteq StopInst\<up> ValidInst\<up>)"
axioms "hyp_11": "T (EB_Log.bnoteq StopInst\<up> (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_12": "T (EB_Log0.beq ValidInst\<up> (ExecInst\<up> .\<union>. StopInst\<up>))"
axioms "hyp_13": "T (EB_Log0.beq (ExecInst\<up> .\<inter>. StopInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_14": "T (EB_Set.bsubseteq IncrInst\<up> ExecInst\<up>)"
axioms "hyp_15": "T (EB_Log.bnoteq IncrInst\<up> (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_16": "T (EB_Set.bsubseteq FlowInst\<up> ExecInst\<up>)"
axioms "hyp_17": "T (EB_Log.bnoteq FlowInst\<up> (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_18": "T (EB_Log0.beq ExecInst\<up> (IncrInst\<up> .\<union>. FlowInst\<up>))"
axioms "hyp_19": "T (EB_Log0.beq (IncrInst\<up> .\<inter>. FlowInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_20": "T (EB_Log0.beq (IncrInst\<up> .\<inter>. StopInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_21": "T (EB_Log0.beq (FlowInst\<up> .\<inter>. StopInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_22": "T (EB_Set.bsubseteq BranchInst\<up> FlowInst\<up>)"
axioms "hyp_23": "T (EB_Set.bsubseteq JumpInst\<up> FlowInst\<up>)"
axioms "hyp_24": "T (EB_Log0.beq (BranchInst\<up> .\<inter>. JumpInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_25": "T (EB_Log0.beq FlowInst\<up> (BranchInst\<up> .\<union>. JumpInst\<up>))"
axioms "hyp_26": "T (EB_Set.bsubseteq NullInst\<up> IncrInst\<up>)"
axioms "hyp_27": "T (EB_Set0.bin NullInstSize\<up> (EB_Int.bnatn))"
axioms "hyp_28": "T (EB_Set.bsubseteq RegWriteInst\<up> IncrInst\<up>)"
axioms "hyp_29": "T (EB_Log0.beq (NullInst\<up> .\<inter>. RegWriteInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_30": "T (EB_Log0.beq IncrInst\<up> (NullInst\<up> .\<union>. RegWriteInst\<up>))"
axioms "hyp_31": "T (EB_Set.bsubseteq FetchInst\<up> RegWriteInst\<up>)"
axioms "hyp_32": "T (EB_Set.bsubseteq MoveInst\<up> RegWriteInst\<up>)"
axioms "hyp_33": "T (EB_Set.bsubseteq SingleOpInst\<up> RegWriteInst\<up>)"
axioms "hyp_34": "T (EB_Set.bsubseteq DualOpInst\<up> RegWriteInst\<up>)"
axioms "hyp_35": "T (EB_Log0.beq (FetchInst\<up> .\<inter>. MoveInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_36": "T (EB_Log0.beq (FetchInst\<up> .\<inter>. SingleOpInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_37": "T (EB_Log0.beq (FetchInst\<up> .\<inter>. DualOpInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_38": "T (EB_Log0.beq (MoveInst\<up> .\<inter>. SingleOpInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_39": "T (EB_Log0.beq (MoveInst\<up> .\<inter>. DualOpInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_40": "T (EB_Log0.beq (SingleOpInst\<up> .\<inter>. DualOpInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_41": "T (EB_Log0.beq RegWriteInst\<up> (FetchInst\<up> .\<union>. MoveInst\<up> .\<union>. SingleOpInst\<up> .\<union>. DualOpInst\<up>))"
axioms "hyp_42": "T (EB_Log.btrue)"
axioms "hyp_43": "T (EB_Set0.bin MoveInstSize\<up> (EB_Int.bnatn))"
axioms "hyp_44": "T (EB_Set0.bin SingleOpInstSize\<up> (EB_Int.bnatn))"
axioms "hyp_45": "T (EB_Set0.bin DualOpInstSize\<up> (EB_Int.bnatn))"
axioms "hyp_46": "T (EB_Set.bsubseteq FetchInstPtrInst\<up> FetchInst\<up>)"
axioms "hyp_47": "T (EB_Set.bsubseteq FetchImmInst\<up> FetchInst\<up>)"
axioms "hyp_48": "T (EB_Set.bsubseteq FetchMemInst\<up> FetchInst\<up>)"
axioms "hyp_49": "T (EB_Log0.beq (FetchInstPtrInst\<up> .\<inter>. FetchImmInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_50": "T (EB_Log0.beq (FetchInstPtrInst\<up> .\<inter>. FetchMemInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_51": "T (EB_Log0.beq (FetchImmInst\<up> .\<inter>. FetchMemInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_52": "T (EB_Log0.beq FetchInst\<up> (FetchInstPtrInst\<up> .\<union>. FetchImmInst\<up> .\<union>. FetchMemInst\<up>))"
axioms "hyp_53": "T (EB_Set0.bin FetchInstPtrInstSize\<up> (EB_Int.bnatn))"
axioms "hyp_54": "T (EB_Set0.bin FetchImmInstSize\<up> (EB_Int.bnatn))"
axioms "hyp_55": "T (EB_Set0.bin FetchMemInstSize\<up> (EB_Int.bnatn))"
axioms "hyp_56": "T (EB_Set.bsubseteq Null2Inst\<up> NullInst\<up>)"
axioms "hyp_57": "T (EB_Set.bsubseteq MemWriteInst\<up> NullInst\<up>)"
axioms "hyp_58": "T (EB_Log0.beq (Null2Inst\<up> .\<inter>. MemWriteInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_59": "T (EB_Log0.beq (Null2Inst\<up> .\<union>. MemWriteInst\<up>) NullInst\<up>)"
axioms "hyp_60": "T (EB_Set0.bin MemWriteInstSize\<up> (EB_Int.bnatn))"
axioms "hyp_61": "T (EB_Set.bsubseteq FetchImmByteInst\<up> FetchImmInst\<up>)"
axioms "hyp_62": "T (EB_Set.bsubseteq FetchImmShortInst\<up> FetchImmInst\<up>)"
axioms "hyp_63": "T (EB_Set.bsubseteq FetchImmLongInst\<up> FetchImmInst\<up>)"
axioms "hyp_64": "T (EB_Log0.beq FetchImmInst\<up> (FetchImmByteInst\<up> .\<union>. FetchImmShortInst\<up> .\<union>. FetchImmLongInst\<up>))"
axioms "hyp_65": "T (EB_Log0.beq (FetchImmByteInst\<up> .\<inter>. FetchImmShortInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_66": "T (EB_Log0.beq (FetchImmShortInst\<up> .\<inter>. FetchImmLongInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_67": "T (EB_Log0.beq (FetchImmLongInst\<up> .\<inter>. FetchImmByteInst\<up>) (EB_Set.bemptyset :: Inst Set.set\<up>))"
axioms "hyp_68": "T (EB_Log0.beq (UNIV::Status Set.set)\<up> {.LOADING\<up>, RUNNING\<up>, FAILED\<up>, HALTED\<up>.})"
axioms "hyp_69": "T (EB_Log.bnoteq LOADING\<up> RUNNING\<up>)"
axioms "hyp_70": "T (EB_Log.bnoteq LOADING\<up> FAILED\<up>)"
axioms "hyp_71": "T (EB_Log.bnoteq LOADING\<up> HALTED\<up>)"
axioms "hyp_72": "T (EB_Log.bnoteq RUNNING\<up> FAILED\<up>)"
axioms "hyp_73": "T (EB_Log.bnoteq RUNNING\<up> HALTED\<up>)"
axioms "hyp_74": "T (EB_Log.bnoteq FAILED\<up> HALTED\<up>)"
axioms "hyp_75": "T (EB_Log.bnoteq (UNIV::Data Set.set)\<up> (EB_Set.bemptyset :: Data Set.set\<up>))"
axioms "hyp_76": "T (EB_Set0.bin SingleOpFunc\<up> (EB_Rel.btfun (UNIV::Data Set.set)\<up> (EB_Rel.bcprod (UNIV::Data Set.set)\<up> (EB_Bool.bbool))))"
axioms "hyp_77": "T (EB_Set0.bin DualOpFunc\<up> (EB_Rel.btfun (EB_Rel.bcprod (UNIV::Data Set.set)\<up> (UNIV::Data Set.set)\<up>) (EB_Rel.bcprod (UNIV::Data Set.set)\<up> (EB_Bool.bbool))))"
axioms "hyp_78": "T (EB_Set.bsubseteq DataLong\<up> (UNIV::Data Set.set)\<up>)"
axioms "hyp_79": "T (EB_Log.bnoteq DataLong\<up> (EB_Set.bemptyset :: Data Set.set\<up>))"
axioms "hyp_80": "T (EB_Set.bsubseteq DataShort\<up> DataLong\<up>)"
axioms "hyp_81": "T (EB_Log.bnoteq DataShort\<up> (EB_Set.bemptyset :: Data Set.set\<up>))"
axioms "hyp_82": "T (EB_Set.bsubseteq DataByte\<up> DataShort\<up>)"
axioms "hyp_83": "T (EB_Log.bnoteq DataByte\<up> (EB_Set.bemptyset :: Data Set.set\<up>))"
axioms "hyp_84": "T (EB_Set0.bin DataLongSize\<up> (EB_Int.bnatn))"
axioms "hyp_85": "T (EB_Set0.bin DataShortSize\<up> (EB_Int.bnatn))"
axioms "hyp_86": "T (EB_Int.ble DataShortSize\<up> DataLongSize\<up>)"
axioms "hyp_87": "T (EB_Set0.bin DataByteSize\<up> (EB_Int.bnatn))"
axioms "hyp_88": "T (EB_Int.ble DataByteSize\<up> DataShortSize\<up>)"
axioms "hyp_89": "T (\<forall>^ (x::Data). (EB_Log.bimp (EB_Set0.bin x\<up> DataShort\<up>) (EB_Set0.bin x\<up> DataLong\<up>)))"
axioms "hyp_90": "T (\<forall>^ (x::Data). (EB_Log.bimp (EB_Set0.bin x\<up> DataByte\<up>) (EB_Set0.bin x\<up> DataShort\<up>)))"
axioms "hyp_91": "T (EB_Set.bsubseteq DataByte\<up> DataLong\<up>)"
axioms "hyp_92": "T (\<forall>^ (x::Data). (EB_Log.bimp (EB_Set0.bin x\<up> DataByte\<up>) (EB_Set0.bin x\<up> DataLong\<up>)))"
axioms "hyp_93": "T (EB_Set0.bin SingleOpFuncDataLong\<up> (EB_Rel.btfun DataLong\<up> (EB_Rel.bcprod DataLong\<up> (EB_Bool.bbool))))"
axioms "hyp_94": "T (\<forall>^ (a::Data). (EB_Log.bimp (EB_Set0.bin a\<up> DataLong\<up>) (EB_Log0.beq (EB_Rel.bfunimg SingleOpFuncDataLong\<up> a\<up>) (EB_Rel.bfunimg SingleOpFunc\<up> a\<up>))))"
axioms "hyp_95": "T (EB_Set0.bin DualOpFuncDataLong\<up> (EB_Rel.btfun (EB_Rel.bcprod DataLong\<up> DataLong\<up>) (EB_Rel.bcprod DataLong\<up> (EB_Bool.bbool))))"
axioms "hyp_96": "T (\<forall>^ (a::Data) (b::Data). (EB_Log.bimp ((EB_Set0.bin a\<up> DataLong\<up>) ^\<and>^ (EB_Set0.bin b\<up> DataLong\<up>)) (EB_Log0.beq (EB_Rel.bfunimg DualOpFuncDataLong\<up> (EB_Prod.bmapsto a\<up> b\<up>)) (EB_Rel.bfunimg DualOpFunc\<up> (EB_Prod.bmapsto a\<up> b\<up>)))))"
axioms "hyp_97": "T (EB_Set0.bin Inst2ImmData\<up> (EB_Rel.btfun (UNIV::Inst Set.set)\<up> (UNIV::Data Set.set)\<up>))"
axioms "hyp_98": "T (EB_Set0.bin Inst2ImmDataByte\<up> (EB_Rel.btfun (UNIV::Inst Set.set)\<up> DataByte\<up>))"
axioms "hyp_99": "T (\<forall>^ (i::Inst). (EB_Log.bimp (EB_Set0.bin i\<up> (UNIV::Inst Set.set)\<up>) (EB_Log0.beq (EB_Rel.bfunimg Inst2ImmDataByte\<up> i\<up>) (EB_Rel.bfunimg Inst2ImmData\<up> i\<up>))))"
axioms "hyp_100": "T (EB_Set0.bin Inst2ImmDataShort\<up> (EB_Rel.btfun (UNIV::Inst Set.set)\<up> DataShort\<up>))"
axioms "hyp_101": "T (\<forall>^ (i::Inst). (EB_Log.bimp (EB_Set0.bin i\<up> (UNIV::Inst Set.set)\<up>) (EB_Log0.beq (EB_Rel.bfunimg Inst2ImmDataShort\<up> i\<up>) (EB_Rel.bfunimg Inst2ImmData\<up> i\<up>))))"
axioms "hyp_102": "T (EB_Set0.bin Inst2ImmDataLong\<up> (EB_Rel.btfun (UNIV::Inst Set.set)\<up> DataLong\<up>))"
axioms "hyp_103": "T (\<forall>^ (i::Inst). (EB_Log.bimp (EB_Set0.bin i\<up> (UNIV::Inst Set.set)\<up>) (EB_Log0.beq (EB_Rel.bfunimg Inst2ImmDataLong\<up> i\<up>) (EB_Rel.bfunimg Inst2ImmData\<up> i\<up>))))"
axioms "hyp_104": "T (EB_Set0.bin Inst2SrcIndex\<up> (EB_Rel.btfun (UNIV::Inst Set.set)\<up> (EB_Int.bnat)))"
axioms "hyp_105": "T (EB_Set0.bin Inst2Src2Index\<up> (EB_Rel.btfun (UNIV::Inst Set.set)\<up> (EB_Int.bnat)))"
axioms "hyp_106": "T (EB_Set0.bin Inst2DstIndex\<up> (EB_Rel.btfun (UNIV::Inst Set.set)\<up> (EB_Int.bnat)))"
axioms "hyp_107": "T (EB_Set.bsubseteq DataInt\<up> (EB_Int.bintg))"
axioms "hyp_108": "T (EB_Set0.bin Data2Int\<up> (EB_Rel.btfun (UNIV::Data Set.set)\<up> DataInt\<up>))"
axioms "hyp_109": "T (EB_Set0.bin Int2Data\<up> (EB_Rel.btfun DataInt\<up> (UNIV::Data Set.set)\<up>))"
axioms "hyp_110": "T (EB_Set0.bin MaxVector\<up> (EB_Int.bnatn))"
axioms "hyp_111": "T (EB_Log0.beq InstArrayDom\<up> (EB_Int.bupto (1::int)\<up> MaxVector\<up>))"
axioms "hyp_112": "T (EB_Log.bnoteq InstArrayDom\<up> (EB_Set.bemptyset :: Int.int Set.set\<up>))"
axioms "hyp_113": "T (EB_Set0.bin MinMemPointer\<up> (EB_Int.bnat))"
axioms "hyp_114": "T (EB_Set0.bin MaxMemPointer\<up> (EB_Int.bnat))"
axioms "hyp_115": "T (EB_Int0.bleq MinMemPointer\<up> MaxMemPointer\<up>)"
axioms "hyp_116": "T (EB_Log0.beq MemArrayDom\<up> (EB_Int.bupto MinMemPointer\<up> MaxMemPointer\<up>))"
axioms "hyp_117": "T (EB_Log.bnoteq MemArrayDom\<up> (EB_Set.bemptyset :: Int.int Set.set\<up>))"
axioms "hyp_118": "T (EB_Log0.beq DataLongInt\<up> DataInt\<up>)"
axioms "hyp_119": "T (EB_Set0.bin Int2DataLong\<up> (EB_Rel.btfun DataLongInt\<up> DataLong\<up>))"
axioms "hyp_120": "T (\<forall>^ (x::Int.int). (EB_Log.bimp (EB_Set0.bin x\<up> DataLongInt\<up>) (EB_Log0.beq (EB_Rel.bfunimg Int2DataLong\<up> x\<up>) (EB_Rel.bfunimg Int2Data\<up> x\<up>))))"
axioms "hyp_121": "T (EB_Set0.bin DataLong2Int\<up> (EB_Rel.btfun DataLong\<up> DataLongInt\<up>))"
axioms "hyp_122": "T (\<forall>^ (x::Data). (EB_Log.bimp (EB_Set0.bin x\<up> DataLong\<up>) (EB_Log0.beq (EB_Rel.bfunimg DataLong2Int\<up> x\<up>) (EB_Rel.bfunimg Data2Int\<up> x\<up>))))"
axioms "hyp_123": "T (EB_Set.bsubseteq DataByteInt\<up> DataLongInt\<up>)"
axioms "hyp_124": "T (EB_Set0.bin Int2DataByte\<up> (EB_Rel.btfun DataByteInt\<up> DataByte\<up>))"
axioms "hyp_125": "T (\<forall>^ (x::Int.int). (EB_Log.bimp (EB_Set0.bin x\<up> DataByteInt\<up>) (EB_Log0.beq (EB_Rel.bfunimg Int2DataByte\<up> x\<up>) (EB_Rel.bfunimg Int2Data\<up> x\<up>))))"
axioms "hyp_126": "T (EB_Set0.bin DataByte2Int\<up> (EB_Rel.btfun DataByte\<up> DataByteInt\<up>))"
axioms "hyp_127": "T (\<forall>^ (x::Data). (EB_Log.bimp (EB_Set0.bin x\<up> DataByte\<up>) (EB_Log0.beq (EB_Rel.bfunimg DataByte2Int\<up> x\<up>) (EB_Rel.bfunimg Data2Int\<up> x\<up>))))"
axioms "hyp_128": "T (EB_Set0.bin MinRegIndex\<up> (EB_Int.bnat))"
axioms "hyp_129": "T (EB_Set0.bin MaxRegIndex\<up> (EB_Int.bnat))"
axioms "hyp_130": "T (EB_Int0.bleq MinRegIndex\<up> MaxRegIndex\<up>)"
axioms "hyp_131": "T (EB_Log0.beq RegArrayDom\<up> (EB_Int.bupto MinRegIndex\<up> MaxRegIndex\<up>))"
axioms "hyp_132": "T (EB_Log.bnoteq RegArrayDom\<up> (EB_Set.bemptyset :: Int.int Set.set\<up>))"
axioms "hyp_133": "T (EB_Set0.bin inst\<up> (UNIV::Inst Set.set)\<up>)"
axioms "hyp_134": "T (EB_Set0.bin status\<up> (UNIV::Status Set.set)\<up>)"
axioms "hyp_135": "T (EB_Set0.bin instArray\<up> (EB_Rel.btfun InstArrayDom\<up> (UNIV::Inst Set.set)\<up>))"
axioms "hyp_136": "T (EB_Set0.bin instPtr\<up> InstArrayDom\<up>)"
axioms "hyp_137": "T (EB_Log0.beq inst\<up> (EB_Rel.bfunimg instArray\<up> instPtr\<up>))"
axioms "hyp_138": "T (EB_Set0.bin instPtr\<up> (EB_Rel.bdom instArray\<up>))"
axioms "hyp_139": "T (EB_Set0.bin instArray\<up> (EB_Rel.bpfun (EB_Int.bintg) (UNIV::Inst Set.set)\<up>))"
axioms "hyp_140": "T (EB_Set0.bin regArray\<up> (EB_Rel.btfun RegArrayDom\<up> (UNIV::Data Set.set)\<up>))"
axioms "hyp_141": "T (EB_Set0.bin (EB_Rel.bfunimg instArray\<up> instPtr\<up>) (EB_Rel.bdom Inst2SrcIndex\<up>))"
axioms "hyp_142": "T (EB_Set0.bin (EB_Rel.bfunimg instArray\<up> instPtr\<up>) (EB_Rel.bdom Inst2DstIndex\<up>))"
axioms "hyp_143": "T (EB_Set0.bin memArray\<up> (EB_Rel.btfun MemArrayDom\<up> (UNIV::Data Set.set)\<up>))"
axioms "hyp_144": "T (EB_Set0.bin regArrayDataLong\<up> (EB_Rel.btfun RegArrayDom\<up> DataLong\<up>))"
axioms "hyp_145": "T (EB_Set0.bin memArrayDataLong\<up> (EB_Rel.btfun MemArrayDom\<up> DataLong\<up>))"
axioms "hyp_146": "T (\<forall>^ (i::Int.int). (EB_Log.bimp (EB_Set0.bin i\<up> RegArrayDom\<up>) (EB_Log0.beq (EB_Rel.bfunimg regArray\<up> i\<up>) (EB_Rel.bfunimg regArrayDataLong\<up> i\<up>))))"
axioms "hyp_147": "T (\<forall>^ (i::Int.int). (EB_Log.bimp (EB_Set0.bin i\<up> MemArrayDom\<up>) (EB_Log0.beq (EB_Rel.bfunimg memArray\<up> i\<up>) (EB_Rel.bfunimg memArrayDataLong\<up> i\<up>))))"
axioms "hyp_148": "T (EB_Set0.bin (EB_Rel.bfunimg instArray\<up> instPtr\<up>) (UNIV::Inst Set.set)\<up>)"
axioms "hyp_149": "T (EB_Set0.bin (EB_Rel.bfunimg instArray\<up> instPtr\<up>) DualOpInst\<up>)"
axioms "hyp_150": "T (EB_Set0.bin (instPtr\<up> .+. DualOpInstSize\<up>) InstArrayDom\<up>)"
axioms "hyp_151": "T (EB_Log0.beq status\<up> RUNNING\<up>)"
axioms "hyp_152": "T (EB_Log0.beq instr\<up> (EB_Rel.bfunimg instArray\<up> instPtr\<up>))"
axioms "hyp_153": "T (EB_Log0.beq op1Index\<up> (EB_Rel.bfunimg Inst2SrcIndex\<up> instr\<up>))"
axioms "hyp_154": "T (EB_Set0.bin instr\<up> (EB_Rel.bdom Inst2SrcIndex\<up>))"
axioms "hyp_155": "T (EB_Set0.bin Inst2SrcIndex\<up> (EB_Rel.bpfun (UNIV::Inst Set.set)\<up> (EB_Int.bintg)))"
axioms "hyp_156": "T (EB_Set0.bin op1Index\<up> RegArrayDom\<up>)"
axioms "hyp_157": "T (EB_Log0.beq op1Data\<up> (EB_Rel.bfunimg regArrayDataLong\<up> op1Index\<up>))"
axioms "hyp_158": "T (EB_Set0.bin op1Index\<up> (EB_Rel.bdom regArrayDataLong\<up>))"
axioms "hyp_159": "T (EB_Set0.bin regArrayDataLong\<up> (EB_Rel.bpfun (EB_Int.bintg) (UNIV::Data Set.set)\<up>))"
axioms "hyp_160": "T (EB_Log0.beq op2Index\<up> (EB_Rel.bfunimg Inst2Src2Index\<up> instr\<up>))"
axioms "hyp_161": "T (EB_Set0.bin instr\<up> (EB_Rel.bdom Inst2Src2Index\<up>))"
axioms "hyp_162": "T (EB_Set0.bin Inst2Src2Index\<up> (EB_Rel.bpfun (UNIV::Inst Set.set)\<up> (EB_Int.bintg)))"
axioms "hyp_163": "T (EB_Set0.bin op2Index\<up> RegArrayDom\<up>)"
axioms "hyp_164": "T (EB_Log0.beq op2Data\<up> (EB_Rel.bfunimg regArrayDataLong\<up> op2Index\<up>))"
axioms "hyp_165": "T (EB_Set0.bin op2Index\<up> (EB_Rel.bdom regArrayDataLong\<up>))"
axioms "hyp_166": "T (EB_Log0.beq (EB_Prod.bmapsto srcData\<up> funcOk\<up>) (EB_Rel.bfunimg DualOpFuncDataLong\<up> (EB_Prod.bmapsto op1Data\<up> op2Data\<up>)))"
axioms "hyp_167": "T (EB_Set0.bin (EB_Prod.bmapsto op1Data\<up> op2Data\<up>) (EB_Rel.bdom DualOpFuncDataLong\<up>))"
axioms "hyp_168": "T (EB_Set0.bin DualOpFuncDataLong\<up> (EB_Rel.bpfun (EB_Rel.bcprod (UNIV::Data Set.set)\<up> (UNIV::Data Set.set)\<up>) (EB_Rel.bcprod (UNIV::Data Set.set)\<up> (EB_Bool.bbool))))"
axioms "hyp_169": "T (EB_Log0.beq funcOk\<up> (EB_Log.btrue))"
axioms "hyp_170": "T (EB_Log0.beq dstIndex\<up> (EB_Rel.bfunimg Inst2DstIndex\<up> instr\<up>))"
axioms "hyp_171": "T (EB_Set0.bin instr\<up> (EB_Rel.bdom Inst2DstIndex\<up>))"
axioms "hyp_172": "T (EB_Set0.bin Inst2DstIndex\<up> (EB_Rel.bpfun (UNIV::Inst Set.set)\<up> (EB_Int.bintg)))"
axioms "hyp_173": "T (EB_Set0.bin dstIndex\<up> RegArrayDom\<up>)"
axioms "hyp_174": "T (EB_Set0.bin op1Index\<up> (EB_Rel.bdom regArray\<up>))"
axioms "hyp_175": "T (EB_Set0.bin regArray\<up> (EB_Rel.bpfun (EB_Int.bintg) (UNIV::Data Set.set)\<up>))"

(*
locale "DualOpOk_grd9_GRD_goal" = 
axioms "goal": "\<not> F (EB_Log0.beq op1Data\<up> (EB_Rel.bfunimg regArray\<up> op1Index\<up>))"
*)

end
